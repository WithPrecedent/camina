{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"camina","text":"Version Status Documentation Tools Compatibility Stats"},{"location":"#what-is-camina","title":"What is camina?","text":"<p>\"Truth is truth. How you deal with it is up to you.\" - Captain Camina Drummer</p> <p>This package adds functionality to core Python container classes and provides functions for common tasks.</p>"},{"location":"#why-use-camina","title":"Why use camina?","text":""},{"location":"#mappings","title":"Mappings","text":"<ul> <li><code>Dictionary</code>: drop-in replacement for a python dict with an <code>add</code> method for a default mechanism of adding data, a <code>delete</code> method for a default mechanism of deleting data, and a <code>subset</code> method for returning a subset of the key/value pairs in a new <code>Dictionary</code>.</li> <li><code>Catalog</code>: wildcard-accepting dict which is intended for storing different options and strategies. It also returns lists of matches if a list of keys is provided.</li> <li><code>Library</code>: a dictionary that automatically supplies key names for stored items. The 'overwrite' argument determines if a unique key should always be created or whether entries may be overwritten.</li> </ul>"},{"location":"#sequences","title":"Sequences","text":"<ul> <li><code>Listing</code>: drop-in replacement for a python list with an <code>add</code> method for a default mechanism of adding data, a <code>delete</code> method for a default mechanism of deleting data, and a <code>subset</code> method for returning a subset of the key/value pairs in a new <code>Listing</code>.</li> <li><code>Hybrid</code>: iterable with both dict and list interfaces. Stored items must be hashable or have a <code>name</code> attribute.</li> </ul>"},{"location":"#passthrough","title":"Passthrough","text":"<ul> <li><code>Proxy</code>: transparently wraps an object and directs access methods to access the wrapped object when appropriate (under construction for edge cases).</li> </ul>"},{"location":"#converters","title":"Converters","text":"<ul> <li><code>instancify</code>: converts a class to an instance or adds kwargs to a passed instance as attributes.</li> <li><code>listify</code>: converts passed item to a list.</li> <li><code>namify</code>: returns hashable name for passed item.</li> <li><code>numify</code>: attempts to convert passed item to a numerical type.</li> <li><code>pathlibify</code>: converts a str to a pathlib object or leaves it as a pathlib object.</li> <li><code>stringify</code>:</li> <li><code>tuplify</code>: converts a passed item to a tuple.</li> <li><code>typify</code>: converts a str type to other common types, if possible.</li> <li><code>windowify</code>:</li> <li><code>to_dict</code>:</li> <li><code>to_index</code>:</li> <li><code>str_to_index</code>:</li> <li><code>to_int</code>:</li> <li><code>str_to_int</code>:</li> <li><code>float_to_int</code>:</li> <li><code>to_list</code>:</li> <li><code>str_to_list</code>:</li> <li><code>to_float</code>:</li> <li><code>int_to_float</code>:</li> <li><code>str_to_float</code>:</li> <li><code>to_path</code>:</li> <li><code>str_to_path</code>:</li> <li><code>to_str</code>:</li> <li><code>int_to_str</code>:</li> <li><code>float_to_str</code>:</li> <li><code>list_to_str</code>:</li> <li><code>none_to_str</code>:</li> <li><code>path_to_str</code>:</li> <li><code>datetime_to_str</code>:</li> </ul>"},{"location":"#modifiers","title":"Modifiers","text":"<ul> <li>Adders:</li> <li><code>add_prefix</code>: adds a str prefix to item.</li> <li><code>add_slots</code>: adds <code>__slots__</code> to a dataclass.</li> <li><code>add_suffix</code>: adds a str suffix to item.</li> <li>Dividers:</li> <li><code>cleave</code>: divides an item into 2 parts based on <code>divider</code> argument.</li> <li><code>separate</code>: divides an item into n+1 parts based on <code>divider</code> argument.</li> <li>Subtractors:</li> <li><code>deduplicate</code>: removes duplicate data from an item.</li> <li><code>drop_dunders</code>: drops strings from a list if they start and end with double underscores.</li> <li><code>drop_prefix</code>: removes a str prefix from an item.</li> <li><code>drop_prefix_from_dict</code></li> <li><code>drop_prefix_from_list</code></li> <li><code>drop_prefix_from_set</code></li> <li><code>drop_prefix_from_str</code></li> <li><code>drop_prefix_from_tuple</code></li> <li><code>drop_privates</code></li> <li><code>drop_substring</code>: removes a substring from an item.</li> <li><code>drop_suffix</code>: removes a str suffix from an item.</li> <li><code>drop_suffix_from_dict</code></li> <li><code>drop_suffix_from_list</code></li> <li><code>drop_suffix_from_set</code></li> <li><code>drop_suffix_from_str</code></li> <li><code>drop_suffix_from_tuple</code></li> <li>Other:</li> <li><code>capitalify</code>: converts a snake case str to capital case.</li> <li><code>snakify</code>: converts a capital case str to snake case.</li> <li><code>uniquify</code>: returns a unique key for a dict.</li> </ul>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#requirements","title":"Requirements","text":"<p>[TODO: List any OS or other restrictions and pre-installation dependencies]</p>"},{"location":"#installation","title":"Installation","text":"<p>To install <code>camina</code>, use <code>pip</code>:</p> <pre><code>pip install camina\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>[TODO: Describe common use cases, with possible example(s)]</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributors are always welcome. Feel free to grab an issue to work on or make a suggested improvement. If you wish to contribute, please read the Contribution Guide and Code of Conduct.</p>"},{"location":"#similar-projects","title":"Similar Projects","text":"<p>[TODO: If they exist, it is always nice to acknowledge other similar efforts]</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>[TODO: Mention any people or organizations that warrant a special acknowledgment]</p>"},{"location":"#license","title":"License","text":"<p>Use of this repository is authorized under the Apache Software License 2.0.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#010","title":"0.1.0","text":"<pre><code>Initial Commit\n</code></pre>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or   advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all project spaces, and it also applies when an individual is representing the project or its community in public spaces. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting any of the following people:</p> <ul> <li>Corey Rayburn Yung (coreyrayburnyung@gmail.com)</li> </ul> <p>All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome and greatly appreciated! Every little bit helps, and credit will always be given. Environment Setup</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Follow this basic process:</p> <ol> <li>Fork and clone the repositor.</li> <li>Create a new branch: <code>git checkout -b feature-or-bugfix-name</code>.</li> <li>Edit the code.</li> <li>If you added functionality or features, update the documentation accordingly.</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#converters","title":"Converters","text":"<p>If you are adding a function to <code>convert.py</code>, you should follow one of two forms. For conversion of a known type to another type, the function name should be:</p> <pre><code>f'{item type}_to_{output type}'\n</code></pre> <p>For a conversion from an unknown type to another type, the function name should be:</p> <pre><code>f'to_{output type}'\n</code></pre>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"contributing/#style-guidelines","title":"Style Guidelines","text":"<p>This package follows the Google Python Style Guide with two notable exceptions:</p> <ol> <li>It always adds spaces around \"=\". This not only violates the Google guide, it violates PEP8, the foundational Python style guide from which all other resources are derived. I defy this strong, long-standign norm because I find it more readable. My brain and eyes have trouble seeing two separate objects when an equal sign is in the middle. I imagine that I am not alone in this accessibility issue. Further, as PEP8 itself notes, required spaces around equal signs are becoming increasing common with type annotations becoming part of best practices (and, as a result, signatures to classes, functions, and methods regularly include spaces around the equal signs). I realize that this will seem alien to many coders, but it is far easier on my eyes.</li> <li>I use some so-called \"power features\", primarily dunder methods, to make my interfaces easier to access and use. This is disfavored in the Google Python Style Guide because such code is often more difficult for others to read. To address that concern, I try to document and comment as to what the code is doing whenever I used any of the \"power features\" of Python.</li> </ol>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build camina. Thank you!</p> <p><code>python</code> | <code>pdm</code></p> </p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>miller</code> introspection tools using consistent, accessible syntax <code>&gt;= 0.1.8</code> <code>0.1.8</code> Apache-2.0 <code>nagata</code> python file management using a common, intuitive syntax <code>&lt;0.2.0,&gt;=0.1.5</code> <code>0.1.6</code> Apache-2.0"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>babel</code> Internationalization utilities <code>~=2.10</code> <code>2.12.1</code> BSD <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2023.7.22</code> MPL-2.0 <code>cfgv</code> Validate configuration and produce human readable error messages. <code>&gt;=2.0.0</code> <code>3.4.0</code> MIT <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.2.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=7.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>&gt;= 7.2.7</code> <code>7.3.1</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>distlib</code> Distribution utilities <code>&lt;1,&gt;=0.3.7</code> <code>0.3.7</code> PSF-2.0 <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.3</code> ? <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT License <code>filelock</code> A platform independent file lock. <code>&lt;4,&gt;=3.12.2</code> <code>3.12.4</code> The Unlicense (Unlicense) <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.37</code> BSD <code>griffe</code> Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=0.35</code> <code>0.36.2</code> ISC <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>identify</code> File identification library for Python <code>&gt;=1.0.0</code> <code>2.5.29</code> MIT <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>&gt;=4.3; python_version &lt; \"3.10\"</code> <code>6.8.0</code> ? <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&gt;=2.11.1</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.9</code> <code>4.9.3</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.4.4</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;= 0.3</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;= 1.6.0</code> <code>1.6.0</code> ISC <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0.1</code> <code>2.1.3</code> BSD-3-Clause <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;= 1.5.2</code> <code>1.5.3</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;= 1.0.0</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;= 0.5.0</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page. The git-committers plugin will seed the template context with a list of github committers and other useful GIT info such as last modified date <code>&gt;= 1.1.2</code> <code>1.2.0</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;= 0.6.0</code> <code>0.6.1</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;= 9.1.2</code> <code>9.4.1</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>~=1.2</code> <code>1.2</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;= 0.7.1</code> <code>0.7.1</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python] &gt;= 0.22.0</code> <code>0.23.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.7.0</code> ISC <code>nodeenv</code> Node.js virtual environment builder <code>&gt;=0.11.1</code> <code>1.8.0</code> BSD <code>packaging</code> Core utilities for Python packages <code>&gt;=20.5</code> <code>23.1</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.11.1</code> <code>0.11.2</code> Mozilla Public License 2.0 (MPL 2.0) <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2.2.0</code> <code>3.10.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.3.0</code> MIT <code>pre-commit</code> A framework for managing and maintaining multi-language pre-commit hooks. <code>&gt;= 3.3.3</code> <code>3.4.0</code> MIT <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>~=2.16</code> <code>2.16.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.3</code> MIT License <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;= 7.4.0</code> <code>7.4.2</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;= 4.1.0</code> <code>4.1.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;= 3.13.0</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;= 3.3.1</code> <code>3.3.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>regex</code> Alternative regular expression module, to replace re. <code>~=2022.4</code> <code>2022.10.31</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;= 0.0.286</code> <code>0.0.291</code> MIT <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>68.2.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.1</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.5</code> MIT License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;= 0.10.2</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>; python_full_version &lt;= \"3.11.0a6\"</code> <code>2.0.1</code> ? <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.5</code> MIT License <code>virtualenv</code> Virtual Python Environment builder <code>&gt;=20.10.0</code> <code>20.24.5</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0 <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.17.0</code> ?"},{"location":"license/","title":"License","text":"<p>Apache Software License 2.0</p> <p>Copyright \u00a9 2023, Corey Rayburn Yung</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> camina<ul> <li> base</li> <li> clock</li> <li> configuration</li> <li> convert</li> <li> label</li> <li> mapping</li> <li> modify</li> <li> sequence</li> </ul> </li> </ul>"},{"location":"reference/camina/","title":"Index","text":"<p>Flexible, lightweight, extensible, easy-to-use data structures and types</p>"},{"location":"reference/camina/#camina.Catalog","title":"<code>Catalog</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dictionary</code></p> <p>Wildcard and list-accepting dictionary.</p> <p>A Catalog inherits the differences between a Dictionary and an ordinary python dict.</p> A Catalog differs from a Dictionary in 5 significant ways <p>1) It recognizes an 'all' key which will return a list of all values     stored in a Catalog instance. 2) It recognizes a 'default' key which will return all values matching     keys listed in the 'default' attribute. 'default' can also be set     using the 'catalog['default'] = new_default' assignment. If     'default' is not passed when the instance is initialized, the     initial value of 'default' is 'all'. 3) It recognizes a 'none' key which will return an empty list. 4) It supports a list of keys being accessed with the matching values     returned. For example, 'catalog[['first_key', 'second_key']]' will     return the values for those keys in a list ['first_value',     'second_value']. 5) If a single key is sought, a Catalog can either return the stored     value or a stored value in a list (if 'always_return_list' is     True). The latter option is available to make iteration easier     when the iterator assumes a single type will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Mapping[Hashable, Any]]</code> <p>stored dictionary. Defaults to an empty dict.</p> <code>field(default_factory=dict)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code> <code>default</code> <code>Optional[Any]]</code> <p>a list of keys in 'contents' which will be used to return items when 'default' is sought. If not passed, 'default' will be set to all keys.</p> <code>'all'</code> <code>always_return_list</code> <code>bool</code> <p>whether to return a list even when the key passed is not a list or special access key (True) or to return a list only when a list or special access key is used (False). Defaults to False.</p> <code>False</code>"},{"location":"reference/camina/#camina.Catalog.always_return_list","title":"<code>always_return_list: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/#camina.Catalog.delete","title":"<code>delete(item)</code>","text":"<p>Deletes 'item' in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable | Sequence[Hashable]</code> <p>name(s) of key(s) in 'contents' to delete the key/value pair.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def delete(self, item: Hashable | Sequence[Hashable]) -&gt; None:\n\"\"\"Deletes 'item' in 'contents'.\n    Args:\n        item (Hashable | Sequence[Hashable]): name(s) of key(s) in\n            'contents' to delete the key/value pair.\n    \"\"\"\nkeys = list(convert.iterify(item))\nif all(k in self for k in keys):\nself.contents = {\ni: self.contents[i] for i in self.contents if i not in keys}\nelse:\nraise KeyError(f'{item} not found in the Catalog')\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary","title":"<code>ChainDictionary</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dictionary</code></p> <p>Combines functionality of collections.ChainMap with Dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Dictionary[Hashable, Any]]</code> <p>list of stored Dictionary instances. This is equivalent to the 'maps' attribute of a collections.ChainMap instance but uses a different name for compatibility with base.Bunch. A separate 'maps' property is included which points to 'contents' to ensure compatibility in the opposite direction.</p> <code>field(default_factory=list)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code> <code>return_first</code> <code>Optional[bool]</code> <p>whether to only return the first match found (True) or to search all of the stored Dictionary instances (False). Defaults to True.</p> <code>True</code>"},{"location":"reference/camina/#camina.ChainDictionary.maps","title":"<code>maps: MutableSequence[Dictionary[Hashable, Any]]</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Returns 'contents' attribute.</p> <p>Returns:</p> Type Description <code>MutableSequence[Dictionary[Hashable, Any]]</code> <p>MutableSequence[Dictionary[Hashable, Any]]: stored Dictionary instances.</p>"},{"location":"reference/camina/#camina.ChainDictionary.return_first","title":"<code>return_first: bool | None = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/camina/#camina.ChainDictionary.add","title":"<code>add(item, **kwargs)</code>","text":"<p>Adds 'item' to the 'contents' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[Hashable, Any]</code> <p>items to add to 'contents' attribute.</p> required <code>kwargs</code> <code>Any</code> <p>creates a consistent interface even when subclasses have additional parameters.</p> <code>{}</code> Source code in <code>src/camina/mapping.py</code> <pre><code>def add(self, item: Mapping[Hashable, Any], **kwargs: Any) -&gt; None:\n\"\"\"Adds 'item' to the 'contents' attribute.\n    Args:\n        item (Mapping[Hashable, Any]): items to add to 'contents' attribute.\n        kwargs: creates a consistent interface even when subclasses have\n            additional parameters.\n    \"\"\"\nself.contents.append(item, **kwargs)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.delete","title":"<code>delete(item)</code>","text":"<p>Deletes 'item' in 'contents'.</p> <p>Because a chained mapping can have identical keys in different stored mappings, this method searches through all of the stored Dictionary instances and removes the key wherever it appears.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key in 'contents' to delete the key/value pair.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def delete(self, item: Hashable) -&gt; None:\n\"\"\"Deletes 'item' in 'contents'.\n    Because a chained mapping can have identical keys in different stored\n    mappings, this method searches through all of the stored Dictionary\n    instances and removes the key wherever it appears.\n    Args:\n        item (Hashable): key in 'contents' to delete the key/value pair.\n    \"\"\"\nfor dictionary in self.contents:\nwith contextlib.suppress(KeyError):\ndel dictionary[item]\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.fromkeys","title":"<code>fromkeys(keys, value, **kwargs)</code>  <code>classmethod</code>","text":"<p>Emulates the 'fromkeys' class method from a python dict.</p> <p>Since this method is an awkward fit with a chained map, it just assigns the 'keys' and 'value' to a single Dictionary stored in the 'contents' list.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[Hashable]</code> <p>items to be keys in a new Dictionary.</p> required <code>value</code> <code>Any</code> <p>the value to use for all values in a new Dictionary.</p> required <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>Dictionary</code> <p>formed from 'keys' and 'value'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>@classmethod\ndef fromkeys(\ncls,\nkeys: Sequence[Hashable],\nvalue: Any,\n**kwargs: Any) -&gt; Dictionary:\n\"\"\"Emulates the 'fromkeys' class method from a python dict.\n    Since this method is an awkward fit with a chained map, it just assigns\n    the 'keys' and 'value' to a single Dictionary stored in the 'contents'\n    list.\n    Args:\n        keys (Sequence[Hashable]): items to be keys in a new Dictionary.\n        value (Any): the value to use for all values in a new Dictionary.\n    Returns:\n        Dictionary: formed from 'keys' and 'value'.\n    \"\"\"\nreturn cls(contents = [Dictionary.fromkeys(keys, value, **kwargs)])\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.items","title":"<code>items()</code>","text":"<p>Emulates python dict 'items' method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, Any], ...]</code> <p>tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, Any], ...]:\n\"\"\"Emulates python dict 'items' method.\n    Returns:\n        tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values()))\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.keys","title":"<code>keys()</code>","text":"<p>Returns 'contents' keys as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>tuple[Hashable, ...]: a tuple equivalent to dict.keys().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Returns 'contents' keys as a tuple.\n    Returns:\n        tuple[Hashable, ...]: a tuple equivalent to dict.keys().\n    \"\"\"\nreturn tuple(\nitertools.chain.from_iterable([d.keys() for d in self.contents]))\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.new_child","title":"<code>new_child(m, **kwargs)</code>","text":"<p>Inserts 'm' as the first Dictionary in 'contents'.</p> <p>This method mirrors the functionality and parameters of collections.Chainmap.new_child.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Dictionary</code> <p>new Dictionary to add to 'contents' at index 0.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def new_child(self, m: Dictionary, **kwargs) -&gt; None:\n\"\"\"Inserts 'm' as the first Dictionary in 'contents'.\n    This method mirrors the functionality and parameters of\n    collections.Chainmap.new_child.\n    Args:\n        m (Dictionary): new Dictionary to add to 'contents' at index 0.\n    \"\"\"\nself.contents.insert(0, m)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.parents","title":"<code>parents()</code>","text":"<p>Returns an instance with 'contents' after the first.</p> <p>This method mirrors the functionality of collections.Chainmap.parents.</p> <p>Returns:</p> Name Type Description <code>ChainDictionary</code> <code>ChainDictionary</code> <p>an isntance with all stored Dictionary instances after the first.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def parents(self) -&gt; ChainDictionary:\n\"\"\"Returns an instance with 'contents' after the first.\n    This method mirrors the functionality of collections.Chainmap.parents.\n    Returns:\n        ChainDictionary: an isntance with all stored Dictionary instances\n            after the first.\n    \"\"\"\nreturn self.__class__(\nself.contents[1:],\ndefault_factory = self.default_factory)\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of 'contents'.</p> <p>This method applies 'include' before 'exclude' if both are passed. If 'include' is None, all existing items will be added to the new subset class instance before 'exclude' is applied.</p> <p>This method relies on all stored mappings being compatible with the Dictionary class because it uses the 'subset' method of those stored mappings.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to include in the new Dictionary instance.</p> <code>None</code> <code>exclude</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to exclude from the new Dictionary instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'include' and 'exclude' are both None.</p> <p>Returns:</p> Name Type Description <code>ChainDictionary</code> <code>ChainDictionary</code> <p>with only keys from 'include' and no keys in 'exclude'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def subset(\nself,\ninclude: Hashable | Sequence[Hashable] | None = None,\nexclude: Hashable | Sequence[Hashable] | None = None) -&gt; (\nChainDictionary):\n\"\"\"Returns a new instance with a subset of 'contents'.\n    This method applies 'include' before 'exclude' if both are passed. If\n    'include' is None, all existing items will be added to the new subset\n    class instance before 'exclude' is applied.\n    This method relies on all stored mappings being compatible with the\n    Dictionary class because it uses the 'subset' method of those stored\n    mappings.\n    Args:\n        include (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            include in the new Dictionary instance.\n        exclude (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            exclude from the new Dictionary instance.\n    Raises:\n        ValueError: if 'include' and 'exclude' are both None.\n    Returns:\n        ChainDictionary: with only keys from 'include' and no keys in\n            'exclude'.\n    \"\"\"\nnew_contents = []\nfor dictionary in self.contents:\nnew_contents.append(\ndictionary.subset(include = include, exclude = exclude))\nnew_dictionary = copy.deepcopy(self)\nnew_dictionary.contents = new_contents\nreturn new_dictionary\n</code></pre>"},{"location":"reference/camina/#camina.ChainDictionary.values","title":"<code>values()</code>","text":"<p>Returns 'contents' values as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: a tuple equivalent to dict.values().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Returns 'contents' values as a tuple.\n    Returns:\n        tuple[Any, ...]: a tuple equivalent to dict.values().\n    \"\"\"\nreturn tuple(\nitertools.chain.from_iterable([d.values() for d in self.contents]))\n</code></pre>"},{"location":"reference/camina/#camina.Descriptor","title":"<code>Descriptor</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Base for descriptors.</p> <p>Since Python currently lacks an abstract base class for descriptors, this class sets the basic interface for one and offers a fully-featured <code>__set_name__</code> method. Since <code>__delete__</code> isn<code>t a strict requirement for a descriptor (typical use cases simply rely on a call to</code>get`), it is not included.</p> <p>The code in this class is derived from a HowTo Guide in the official Python docs: https://docs.python.org/3/howto/descriptor.html</p> <p>Attributes:</p> Name Type Description <code>attribute_name</code> <p>name of the attribute for the Descriptor instance in <code>owner</code>.</p> <code>private_name</code> <p><code>attribute_name</code> with a leading underscore added. This attribute contains the name of an attribute in <code>owner</code> (and not the descriptor) where the data for a descriptor will be stored.</p> <code>owner</code> <p>object of which the Descriptor instance is an attribute.</p>"},{"location":"reference/camina/#camina.Dictionary","title":"<code>Dictionary</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Bunch</code>, <code>MutableMapping</code></p> <p>Basic camina dict replacement.</p> <p>A Dictionary differs from an ordinary python dict in ways inherited from Bunch by requiring 'add' and 'subset' methods, storing data in 'contents', and allowing the '+' operator to join Dictionary instances with other mappings, including Dictionary instances.</p> <p>In addition, it differs in 2 other significant ways:     1) When returning 'keys', 'values' and 'items', this class returns them         as tuples instead of KeysView, ValuesView, and ItemsView.     2) It includes the same functionality as 'defaultdict' in the python         standard library, including a 'setdefault' method.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, Any]</code> <p>stored dictionary. Defaults to an empty dict.</p> <code>field(default_factory=dict)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code>"},{"location":"reference/camina/#camina.Dictionary.default_factory","title":"<code>default_factory: Any | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/camina/#camina.Dictionary.add","title":"<code>add(item, **kwargs)</code>","text":"<p>Adds 'item' to the 'contents' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[Hashable, Any]</code> <p>items to add to 'contents' attribute.</p> required <code>kwargs</code> <code>Any</code> <p>creates a consistent interface even when subclasses have additional parameters.</p> <code>{}</code> Source code in <code>src/camina/mapping.py</code> <pre><code>def add(self, item: Mapping[Hashable, Any], **kwargs: Any) -&gt; None:\n\"\"\"Adds 'item' to the 'contents' attribute.\n    Args:\n        item (Mapping[Hashable, Any]): items to add to 'contents' attribute.\n        kwargs: creates a consistent interface even when subclasses have\n            additional parameters.\n    \"\"\"\nself.contents.update(item, **kwargs)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.delete","title":"<code>delete(item)</code>","text":"<p>Deletes 'item' in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key in 'contents' to delete the key/value pair.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def delete(self, item: Hashable) -&gt; None:\n\"\"\"Deletes 'item' in 'contents'.\n    Args:\n        item (Hashable): key in 'contents' to delete the key/value pair.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.fromkeys","title":"<code>fromkeys(keys, value, **kwargs)</code>  <code>classmethod</code>","text":"<p>Emulates the 'fromkeys' class method from a python dict.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[Hashable]</code> <p>items to be keys in a new Dictionary.</p> required <code>value</code> <code>Any</code> <p>the value to use for all values in a new Dictionary.</p> required <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>Dictionary</code> <p>formed from 'keys' and 'value'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>@classmethod\ndef fromkeys(\ncls,\nkeys: Sequence[Hashable],\nvalue: Any,\n**kwargs: Any) -&gt; Dictionary:\n\"\"\"Emulates the 'fromkeys' class method from a python dict.\n    Args:\n        keys (Sequence[Hashable]): items to be keys in a new Dictionary.\n        value (Any): the value to use for all values in a new Dictionary.\n    Returns:\n        Dictionary: formed from 'keys' and 'value'.\n    \"\"\"\nreturn cls(contents = dict.fromkeys(keys, value), **kwargs)\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.get","title":"<code>get(key, default=None)</code>","text":"<p>Returns value in 'contents' or default options.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key for value in 'contents'.</p> required <code>default</code> <code>Optional[Any]</code> <p>default value to return if 'key' is not found in 'contents'.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if 'key' is not in the Dictionary and 'default' and the 'default_factory' attribute are both None.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>value matching key in 'contents' or 'default_factory' value.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def get(self, key: Hashable, default: Any | None = None) -&gt; Any:\n\"\"\"Returns value in 'contents' or default options.\n    Args:\n        key (Hashable): key for value in 'contents'.\n        default (Optional[Any]): default value to return if 'key' is not\n            found in 'contents'.\n    Raises:\n        KeyError: if 'key' is not in the Dictionary and 'default' and the\n            'default_factory' attribute are both None.\n    Returns:\n        Any: value matching key in 'contents' or 'default_factory' value.\n    \"\"\"\ntry:\nreturn self[key]\nexcept (KeyError, TypeError):\nif default is None:\nif self.default_factory is None:\nraise KeyError(f'{key} is not in the Dictionary')\nelse:\ntry:\nreturn self.default_factory()\nexcept TypeError:\nreturn self.default_factory\nelse:\nreturn default\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.items","title":"<code>items()</code>","text":"<p>Emulates python dict 'items' method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, Any], ...]</code> <p>tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, Any], ...]:\n\"\"\"Emulates python dict 'items' method.\n    Returns:\n        tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values()))\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.keys","title":"<code>keys()</code>","text":"<p>Returns 'contents' keys as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>tuple[Hashable, ...]: a tuple equivalent to dict.keys().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Returns 'contents' keys as a tuple.\n    Returns:\n        tuple[Hashable, ...]: a tuple equivalent to dict.keys().\n    \"\"\"\nreturn tuple(self.contents.keys())\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.setdefault","title":"<code>setdefault(value)</code>","text":"<p>Sets default value to return when 'get' method is used.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>default value to return when 'get' is called and the 'default' parameter to 'get' is None.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def setdefault(self, value: Any) -&gt; None:\n\"\"\"Sets default value to return when 'get' method is used.\n    Args:\n        value (Any): default value to return when 'get' is called and the\n            'default' parameter to 'get' is None.\n    \"\"\"\nself.default_factory = value\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of 'contents'.</p> <p>This method applies 'include' before 'exclude' if both are passed. If 'include' is None, all existing items will be added to the new subset class instance before 'exclude' is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to include in the new Dictionary instance.</p> <code>None</code> <code>exclude</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to exclude from the new Dictionary instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'include' and 'exclude' are both None.</p> <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>Dictionary</code> <p>with only keys from 'include' and no keys in 'exclude'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def subset(\nself,\ninclude: Hashable | Sequence[Hashable] | None = None,\nexclude: Hashable | Sequence[Hashable] | None = None) -&gt; Dictionary:\n\"\"\"Returns a new instance with a subset of 'contents'.\n    This method applies 'include' before 'exclude' if both are passed. If\n    'include' is None, all existing items will be added to the new subset\n    class instance before 'exclude' is applied.\n    Args:\n        include (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            include in the new Dictionary instance.\n        exclude (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            exclude from the new Dictionary instance.\n    Raises:\n        ValueError: if 'include' and 'exclude' are both None.\n    Returns:\n        Dictionary: with only keys from 'include' and no keys in 'exclude'.\n    \"\"\"\nif include is None and exclude is None:\nraise ValueError('include or exclude must not be None')\nelse:\nif include is None:\ncontents = copy.deepcopy(self.contents)\nelse:\ninclude = list(convert.iterify(include))\ncontents = {k: self.contents[k] for k in include}\nif exclude is not None:\nexclude = list(convert.iterify(exclude))\ncontents = {\nk: v for k, v in contents.items()\nif k not in exclude}\nnew_dictionary = copy.deepcopy(self)\nnew_dictionary.contents = contents\nreturn new_dictionary\n</code></pre>"},{"location":"reference/camina/#camina.Dictionary.values","title":"<code>values()</code>","text":"<p>Returns 'contents' values as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: a tuple equivalent to dict.values().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Returns 'contents' values as a tuple.\n    Returns:\n        tuple[Any, ...]: a tuple equivalent to dict.values().\n    \"\"\"\nreturn tuple(self.contents.values())\n</code></pre>"},{"location":"reference/camina/#camina.Listing","title":"<code>Listing</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Bunch</code>, <code>MutableSequence</code></p> <p>Basic camina list replacement.</p> <p>A Listing differs from an ordinary python list in ways required by inheriting from Bunch: 'add', 'delete', and 'subset' methods, and allowing the '+' operator to join Listings with other list-like objects) and in 1 other way:     1) It includes a 'prepend' method for adding one or more items to the         beginning of the stored list.</p> <p>The 'add' method attempts to extend 'contents' with the item to be added. If this fails, it appends the item to 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Any]</code> <p>items to store in a list. Defaults to an empty list.</p> <code>field(default_factory=list)</code>"},{"location":"reference/camina/#camina.Listing.contents","title":"<code>contents: MutableSequence[Any] = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/#camina.Listing.add","title":"<code>add(item)</code>","text":"<p>Tries to extend 'contents' with 'item'. Otherwise, it appends.</p> <p>The method will extend all passed sequences, except str types, which it will append.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | Sequence[Any]</code> <p>item(s) to add to 'contents'.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def add(self, item: Any | Sequence[Any]) -&gt; None:\n\"\"\"Tries to extend 'contents' with 'item'. Otherwise, it appends.\n    The method will extend all passed sequences, except str types, which it\n    will append.\n    Args:\n        item (Any | Sequence[Any]): item(s) to add to 'contents'.\n    \"\"\"\nif miller.is_sequence(item = item):\nself.contents.extend(item)\nelse:\nself.contents.append(item)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Listing.delete","title":"<code>delete(item)</code>","text":"<p>Deletes item at the index in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>index in 'contents' to delete.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def delete(self, item: int) -&gt; None:\n\"\"\"Deletes item at the index in 'contents'.\n    Args:\n        item (Any): index in 'contents' to delete.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Listing.insert","title":"<code>insert(index, item)</code>","text":"<p>Inserts 'item' at 'index' in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index to insert 'item' at.</p> required <code>item</code> <code>Any</code> <p>object to be inserted.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def insert(self, index: int, item: Any) -&gt; None:\n\"\"\"Inserts 'item' at 'index' in 'contents'.\n    Args:\n        index (int): index to insert 'item' at.\n        item (Any): object to be inserted.\n    \"\"\"\nself.contents.insert(index, item)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Listing.prepend","title":"<code>prepend(item)</code>","text":"<p>Prepends 'item' to 'contents'.</p> <p>If 'item' is a non-str sequence, 'prepend' adds its contents to the stored list in the order they appear in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | Sequence[Any]</code> <p>item(s) to prepend to 'contents'.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def prepend(self, item: Any | Sequence[Any]) -&gt; None:\n\"\"\"Prepends 'item' to 'contents'.\n    If 'item' is a non-str sequence, 'prepend' adds its contents to the\n    stored list in the order they appear in 'item'.\n    Args:\n        item (Any | Sequence[Any]): item(s) to prepend to 'contents'.\n    \"\"\"\nif miller.is_sequence(item = item):\nfor thing in reversed(item):\nself.prepend(item = thing)\nelse:\nself.insert(0, item)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.Listing.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of 'contents'.</p> <p>This method applies 'include' before 'exclude' if both are passed. If 'include' is None, all existing items will be added to the new subset class instance before 'exclude' is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Any | Sequence[Any]]</code> <p>item(s) to include in the new instance. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>Optional[Any | Sequence[Any]]</code> <p>item(s) to exclude in the new instance. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'include' and 'exclude' are both None.</p> <p>Returns:</p> Name Type Description <code>Listing</code> <code>Listing</code> <p>with only items from 'include' and no items in 'exclude'.</p> Source code in <code>src/camina/sequence.py</code> <pre><code>def subset(\nself,\ninclude: Any | Sequence[Any] | None = None,\nexclude: Any | Sequence[Any] | None = None) -&gt; Listing:\n\"\"\"Returns a new instance with a subset of 'contents'.\n    This method applies 'include' before 'exclude' if both are passed. If\n    'include' is None, all existing items will be added to the new subset\n    class instance before 'exclude' is applied.\n    Args:\n        include (Optional[Any | Sequence[Any]]): item(s) to include in\n            the new instance. Defaults to None.\n        exclude (Optional[Any | Sequence[Any]]): item(s) to exclude in\n            the new instance. Defaults to None.\n    Raises:\n        ValueError: if 'include' and 'exclude' are both None.\n    Returns:\n        Listing: with only items from 'include' and no items in 'exclude'.\n    \"\"\"\nif include is None and exclude is None:\nraise ValueError('include or exclude must not be None')\nelse:\nif include is None:\ncontents = copy.deepcopy(self.contents)\nelse:\ninclude = list(convert.iterify(include))\ncontents = [i for i in self.contents if i in include]\nif exclude is not None:\nexclude = list(convert.iterify(exclude))\ncontents = [i for i in contents if i not in exclude]\nnew_listing = copy.deepcopy(self)\nnew_listing.contents = contents\nreturn new_listing\n</code></pre>"},{"location":"reference/camina/#camina.Name","title":"<code>Name</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Descriptor for a name attribute.</p> <p>This class automatically provides a name attribute to an object using the '_KEY_NAMER' function.</p> <p>Parameters:</p> Name Type Description Default <code>_KEY_NAMER</code> <code>Optional[Callable[[object | Type[Any]], str]]</code> <p>function that creates a name if one has not been stored. Defaults to namify.</p> <code>namify</code> <p>Attributes:</p> Name Type Description <code>private_name</code> <code>str</code> <p>the name of the attribute in the owner instance with a leading underscore added.</p>"},{"location":"reference/camina/#camina.Name._KEY_NAMER","title":"<code>_KEY_NAMER: Callable[[object | type[Any]], str] | None = namify</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/camina/#camina.Proxy","title":"<code>Proxy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Container</code></p> <p>Mostly transparent wrapper class.</p> A Proxy differs than an ordinary container in 2 significant ways <p>1) Access methods for getting, setting, and deleting that try to     intelligently direct the user's call to the proxy or stored object.     So, for example, when a user tries to set an attribute on the proxy,     the method will replace an attribute that exists in the proxy if     one exists. But if there is no such attribute, the set method is     applied to the object stored in <code>contents</code>. 2) When an <code>in</code> call is made, the <code>__contains__</code> method first looks to     see if the item is stored in <code>contents</code> (if <code>contents</code> is a     collection). If that check gets an errorr, the method then checks     if the item is equivalent to <code>contents</code>. This allows a Proxy to be     agnostic as to the type of item(s) in <code>contents</code> while returning the     expected result from an <code>in</code> call.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Any | None</code> <p>any stored item(s). Defaults to None.</p> <code>None</code> To Do <p>Add more dunder methods to address less common and fringe cases for use     of a Proxy class.</p>"},{"location":"reference/camina/#camina.Proxy.contents","title":"<code>contents: Any | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/camina/#camina.Repository","title":"<code>Repository</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dictionary</code></p> <p>Dictionary with inferred keys based on items added.</p> <p>A Repository differs from an ordinary python dict in ways inherited from Dictionary. In addition, it differs in 2 other significant ways:     1) The 'add' method relies on the internal '_get_name__' method to         assign a str key for the passed item.     2) It includes an 'overwrite' parameter which allows users to determine         whether existing items will be overwritten when the inferred key         matches an existing one or whether a new key will be inferred by         adding an integer counter as a suffix to the key.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, Any]</code> <p>stored dictionary. Defaults to an empty dict.</p> <code>field(default_factory=dict)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code> <code>overwrite</code> <code>Optional[bool]</code> <p>whether to overwrite existing items in the stored dictionary with the same inferred keys (True) or automatically infer a new key based upon a counter suffix (False). Defaults to False.</p> <code>False</code>"},{"location":"reference/camina/#camina.Repository.overwrite","title":"<code>overwrite: bool | None = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/#camina.Repository._get_name","title":"<code>_get_name(item)</code>","text":"<p>Infers key name for 'item'</p> <p>By default, this method uses the 'namify' function in camina. Override this method to use a different naming function.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to infer the name for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>inferred name.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def _get_name(self, item: Any) -&gt; str:\n\"\"\"Infers key name for 'item'\n    By default, this method uses the 'namify' function in camina. Override\n    this method to use a different naming function.\n    Args:\n        item (Any): item to infer the name for.\n    Returns:\n        str: inferred name.\n    \"\"\"\nreturn label.namify(item)\n</code></pre>"},{"location":"reference/camina/#camina.Repository.add","title":"<code>add(item, key=None, **kwargs)</code>","text":"<p>Adds 'item' to the 'contents' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to add to 'contents' attribute.</p> required <code>key</code> <code>Optional[str]</code> <p>key to use for 'item' if the user does not want the key to be inferred.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>creates a consistent interface even when subclasses have additional parameters.</p> <code>{}</code> Source code in <code>src/camina/mapping.py</code> <pre><code>def add(self, item: Any, key: str | None = None, **kwargs: Any) -&gt; None:\n\"\"\"Adds 'item' to the 'contents' attribute.\n    Args:\n        item (Any): item to add to 'contents' attribute.\n        key (Optional[str]): key to use for 'item' if the user does not want\n            the key to be inferred.\n        kwargs: creates a consistent interface even when subclasses have\n            additional parameters.\n    \"\"\"\nkey = key or self._get_name(item = item)\nif not self.overwrite:\nkey = modify.uniquify(key = key, dictionary = self)\nself.contents.update({key: item}, **kwargs)\nreturn\n</code></pre>"},{"location":"reference/camina/#camina.add_prefix","title":"<code>add_prefix(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>Optional[str]</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef add_prefix(\nitem: Any, /,\nprefix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Any:\n\"\"\"Adds 'prefix' to 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (Optional[str]): str to add between 'item' and 'prefix'.\n            Defaults to '', which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified item.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.add_prefix_to_dict","title":"<code>add_prefix_to_dict(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(Mapping)\ndef add_prefix_to_dict(\nitem: Mapping[str, Any], /,\nprefix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Mapping[str, Any]:\n\"\"\"Adds 'prefix' to keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\nbase = type(item)\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\ntool = add_prefix if recursive else add_prefix_to_str\nreturn base({tool(k, **kwargs): v for k, v in item.items()})\n</code></pre>"},{"location":"reference/camina/#camina.add_prefix_to_list","title":"<code>add_prefix_to_list(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>MutableSequence[str]</code> <p>modified mutable sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(MutableSequence)\ndef add_prefix_to_list(\nitem: MutableSequence[str], /,\nprefix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; MutableSequence[str]:\n\"\"\"Adds 'prefix' to items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified mutable sequence.\n    \"\"\"\nbase = type(item)\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\ntool = add_prefix if recursive else add_prefix_to_str\nreturn base([tool(i, **kwargs) for i in item])\n</code></pre>"},{"location":"reference/camina/#camina.add_prefix_to_set","title":"<code>add_prefix_to_set(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(AbstractSet)\ndef add_prefix_to_set(\nitem: AbstractSet[str], /,\nprefix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; AbstractSet[str]:\n\"\"\"Adds 'prefix' to items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\nbase = type(item)\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\ntool = add_prefix if recursive else add_prefix_to_str\nreturn base({tool(i, **kwargs) for i in item})\n</code></pre>"},{"location":"reference/camina/#camina.add_prefix_to_str","title":"<code>add_prefix_to_str(item, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False. This argument has no effect if 'item' is a str type.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(str)\ndef add_prefix_to_str(\nitem: str,\nprefix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; str:\n\"\"\"Adds 'prefix' to 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False. This argument has no effect\n            if 'item' is a str type.\n    Returns:\n        str: modified str.\n    \"\"\"\nreturn divider.join([prefix, item])\n</code></pre>"},{"location":"reference/camina/#camina.add_prefix_to_tuple","title":"<code>add_prefix_to_tuple(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(tuple)\ndef add_prefix_to_tuple(\nitem: tuple[str, ...], /,\nprefix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; tuple[str, ...]:\n\"\"\"Adds 'prefix' to items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\nreturn tuple(add_prefix_to_list(item, **kwargs))\n</code></pre>"},{"location":"reference/camina/#camina.add_slots","title":"<code>add_slots(item)</code>","text":"<p>Adds slots to dataclass with default values.</p> <p>Derived from code here: https://gitquirks.com/ericvsmith/dataclasses/blob/master/dataclass_tools.py</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any]</code> <p>dataclass to add slots to.</p> required <p>Returns:</p> Type Description <code>type[Any]</code> <p>Type[Any]: class with 'slots' added.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'slots' is already in item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def add_slots(item: type[Any]) -&gt; type[Any]:\n\"\"\"Adds slots to dataclass with default values.\n    Derived from code here:\n    https://gitquirks.com/ericvsmith/dataclasses/blob/master/dataclass_tools.py\n    Args:\n        item (Type[Any]): dataclass to add slots to.\n    Returns:\n        Type[Any]: class with '__slots__' added.\n    Raises:\n        TypeError: if '__slots__' is already in item.\n    \"\"\"\nif '__slots__' in item.__dict__:\nraise TypeError(f'{item.__name__} already contains __slots__')\nelse:\nitem_dict = dict(item.__dict__)\nfield_names = tuple(f.name for f in dataclasses.fields(item))\nitem_dict['__slots__'] = field_names\nfor field_name in field_names:\nitem_dict.pop(field_name, None)\nitem_dict.pop('__dict__', None)\nqualname = getattr(item, '__qualname__', None)\nitem = type(item)(item.__name__, item.__bases__, item_dict)\nif qualname is not None:\nitem.__qualname__ = qualname\nreturn item\n</code></pre>"},{"location":"reference/camina/#camina.add_suffix","title":"<code>add_suffix(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>Optional[str]</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef add_suffix(\nitem: Any, /,\nsuffix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Any:\n\"\"\"Adds 'suffix' to 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (Optional[str]): str to add between 'item' and 'suffix'.\n            Defaults to '', which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified item.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.add_suffix_to_dict","title":"<code>add_suffix_to_dict(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(Mapping)\ndef add_suffix_to_dict(\nitem: Mapping[str, Any], /,\nsuffix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Mapping[str, Any]:\n\"\"\"Adds 'suffix' to keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\nbase = type(item)\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\ntool = add_suffix if recursive else add_suffix_to_str\nreturn base({tool(k, **kwargs): v for k, v in item.items()})\n</code></pre>"},{"location":"reference/camina/#camina.add_suffix_to_list","title":"<code>add_suffix_to_list(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>MutableSequence[str]</code> <p>modified mutable sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(MutableSequence)\ndef add_suffix_to_list(\nitem: MutableSequence[str], /,\nsuffix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; MutableSequence[str]:\n\"\"\"Adds 'suffix' to items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified mutable sequence.\n    \"\"\"\nbase = type(item)\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\ntool = add_suffix if recursive else add_suffix_to_str\nreturn base([tool(i, **kwargs) for i in item])\n</code></pre>"},{"location":"reference/camina/#camina.add_suffix_to_set","title":"<code>add_suffix_to_set(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(AbstractSet)\ndef add_suffix_to_set(\nitem: AbstractSet[str], /,\nsuffix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; AbstractSet[str]:\n\"\"\"Adds 'suffix' to items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\nbase = type(item)\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\ntool = add_suffix if recursive else add_suffix_to_str\nreturn base({tool(i, **kwargs) for i in item})\n</code></pre>"},{"location":"reference/camina/#camina.add_suffix_to_str","title":"<code>add_suffix_to_str(item, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False. This argument has no effect if 'item' is a str type.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(str)\ndef add_suffix_to_str(\nitem: str,\nsuffix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; str:\n\"\"\"Adds 'suffix' to 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False. This argument has no effect\n            if 'item' is a str type.\n    Returns:\n        str: modified str.\n    \"\"\"\nreturn divider.join([item, suffix])\n</code></pre>"},{"location":"reference/camina/#camina.add_suffix_to_tuple","title":"<code>add_suffix_to_tuple(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(tuple)\ndef add_suffix_to_tuple(\nitem: tuple[str, ...], /,\nsuffix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; tuple[str, ...]:\n\"\"\"Adds 'suffix' to items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\nreturn tuple(add_suffix_to_list(item, **kwargs))\n</code></pre>"},{"location":"reference/camina/#camina.capitalify","title":"<code>capitalify(item)</code>","text":"<p>Converts a snake case str to capital case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'item' converted to capital case.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def capitalify(item: str) -&gt; str:\n\"\"\"Converts a snake case str to capital case.\n    Args:\n        item (str): str to convert.\n    Returns:\n        str: 'item' converted to capital case.\n    \"\"\"\nreturn item.replace('_', ' ').title().replace(' ', '')\n</code></pre>"},{"location":"reference/camina/#camina.cleave","title":"<code>cleave(item, /, divider, return_last=True, raise_error=False)</code>","text":"<p>Divides 'item' into 2 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide 'item' upon.</p> required <code>return_last</code> <code>bool</code> <p>whether to split 'item' upon the first (False) or last appearance of 'divider'.</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>tuple[Any, Any]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef cleave(\nitem: Any, /,\ndivider: Any,\nreturn_last: bool = True,\nraise_error: bool = False) -&gt; tuple[Any, Any]:\n\"\"\"Divides 'item' into 2 parts based on 'divider'.\n    Args:\n        item (Any): item to be divided.\n        divider (Any): item to divide 'item' upon.\n        return_last (bool): whether to split 'item' upon the first (False) or\n            last appearance of 'divider'.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        tuple[Any, Any]: parts of 'item' on either side of 'divider' unless\n            'divider' is not in 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.cleave_str","title":"<code>cleave_str(item, /, divider='_', return_last=True, raise_error=False)</code>","text":"<p>Divides 'item' into 2 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be divided.</p> required <code>divider</code> <code>str</code> <p>item to divide 'item' upon.</p> <code>'_'</code> <code>return_last</code> <code>bool</code> <p>whether to split 'item' upon the first (False) or last appearance of 'divider'.</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'divider' is not in 'item' and 'raise_error' is True.</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@cleave.register\ndef cleave_str(\nitem: str, /,\ndivider: str = '_',\nreturn_last: bool = True,\nraise_error: bool = False) -&gt; tuple[str, str]:\n\"\"\"Divides 'item' into 2 parts based on 'divider'.\n    Args:\n        item (str): item to be divided.\n        divider (str): item to divide 'item' upon.\n        return_last (bool): whether to split 'item' upon the first (False) or\n            last appearance of 'divider'.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        ValueError: if 'divider' is not in 'item' and 'raise_error' is True.\n    Returns:\n        tuple[str, str]: parts of 'item' on either side of 'divider' unless\n            'divider' is not in 'item'.\n    \"\"\"\nif divider in item:\nif return_last:\nsuffix = item.split(divider)[-1]\nelse:\nsuffix = item.split(divider)[0]\nprefix = item[:-len(suffix) - 1]\nelif raise_error:\nraise ValueError(f'{divider} is not in {item}')\nelse:\nprefix = suffix = item\nreturn prefix, suffix\n</code></pre>"},{"location":"reference/camina/#camina.deduplicate","title":"<code>deduplicate(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to deduplicate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>deduplicated item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef deduplicate(item: Any, /) -&gt; Any:\n\"\"\"Deduplicates contents of 'item.\n    Args:\n        item (Any): item to deduplicate.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: deduplicated item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.deduplicate_list","title":"<code>deduplicate_list(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[Any]</code> <p>item to deduplicate.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Any]</code> <p>MutableSequence[Any]: deduplicated item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@deduplicate.register(MutableSequence)\ndef deduplicate_list(item: MutableSequence[Any], /) -&gt; MutableSequence[Any]:\n\"\"\"Deduplicates contents of 'item.\n    Args:\n        item (MutableSequence[Any]): item to deduplicate.\n    Returns:\n        MutableSequence[Any]: deduplicated item.\n    \"\"\"\nbase = type(item)\ncontents = list(dict.fromkeys(item))\nreturn base(contents)\n</code></pre>"},{"location":"reference/camina/#camina.deduplicate_tuple","title":"<code>deduplicate_tuple(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[Any, ...]</code> <p>item to deduplicate.</p> required <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: deduplicated item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@deduplicate.register(tuple)\ndef deduplicate_tuple(item: tuple[Any, ...], /) -&gt; tuple[Any, ...]:\n\"\"\"Deduplicates contents of 'item.\n    Args:\n        item (tuple[Any, ...]): item to deduplicate.\n    Returns:\n        tuple[Any, ...]: deduplicated item.\n    \"\"\"\nreturn tuple(deduplicate_list(item))\n</code></pre>"},{"location":"reference/camina/#camina.dictify","title":"<code>dictify(item)</code>","text":"<p>Converts <code>item</code> to a MutableMapping.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a MutableMapping.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>MutableMapping</code> <code>MutableMapping[Hashable, Any]</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef dictify(item: Any, /) -&gt; MutableMapping[Hashable, Any]:\n\"\"\"Converts `item` to a MutableMapping.\n    Args:\n        item: item to convert to a MutableMapping.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        MutableMapping: derived from `item`.\n    \"\"\"\nif isinstance(item, MutableMapping):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an unsupported type: '\nf'{type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.drop_dunders","title":"<code>drop_dunders(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to modify.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>item with entries dropped beginning with a double underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not a registered type.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_dunders(item: Any, /) -&gt; Any:\n\"\"\"Drops items in 'item' beginning with a double underscore.\n    Args:\n        item (Any): item to modify.\n    Returns:\n        Any: item with entries dropped beginning with a double underscore.\n    Raises:\n        TypeError: if 'item' is not a registered type.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.drop_dunders_dict","title":"<code>drop_dunders_dict(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>dict-like object with str keys that might have double underscores at the beginning of the key names.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: dict-luke object with entries dropped if the key name begin with a double underscore.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_dunders.register(Mapping)\ndef drop_dunders_dict(item: Mapping[str, Any], /) -&gt; Mapping[str, Any]:\n\"\"\"Drops items in 'item' beginning with a double underscore.\n    Args:\n        item (Mapping[str, Any]): dict-like object with str keys that might have\n            double underscores at the beginning of the key names.\n    Returns:\n        Mapping[str, Any]: dict-luke object with entries dropped if the key name\n            begin with a double underscore.\n    \"\"\"\nbase = type(item)\nreturn base({k: v for k, v in item.items() if not k.startswith('__')})\n</code></pre>"},{"location":"reference/camina/#camina.drop_dunders_list","title":"<code>drop_dunders_list(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str | object]</code> <p>list-like object with str items or names that might have double underscores at their beginnings.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str | object]</code> <p>MutableSequence[str | object]: list-like object with items dropped if they or their names begin with a double underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not contain str types or objects with either 'name' or 'name' attributes.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_dunders.register(MutableSequence)\ndef drop_dunders_list(\nitem: MutableSequence[str | object], /) -&gt; MutableSequence[str | object]:\n\"\"\"Drops items in 'item' beginning with a double underscore.\n    Args:\n        item (MutableSequence[str | object]): list-like object with str items or\n            names that might have double underscores at their beginnings.\n    Returns:\n        MutableSequence[str | object]: list-like object with items dropped if\n            they or their names begin with a double underscore.\n    Raises:\n        TypeError: if 'item' does not contain str types or objects with either\n            'name' or '__name__' attributes.\n    \"\"\"\nbase = type(item)\nif len(item) &gt; 0 and all(isinstance(i, str) for i in item):\nreturn base([i for i in item if not i.startswith('__')])\nelif len(item) &gt; 0 and all(hasattr(i, 'name') for i in item):\nreturn base([i for i in item if not i.name.startswith('__')])\nelif len(item) &gt; 0 and all(hasattr(i, '__name__') for i in item):\nreturn base([i for i in item if not i.__name__.startswith('__')])\nelif len == 0:\nreturn item\nelse:\nraise TypeError(\n'items in item must be str types or have name or __name__ '\n'attributes')\n</code></pre>"},{"location":"reference/camina/#camina.drop_prefix","title":"<code>drop_prefix(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_prefix(item: Any, /, prefix: str, divider: str = '') -&gt; Any:\n\"\"\"Drops 'prefix' from 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: modified item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.drop_prefix_from_dict","title":"<code>drop_prefix_from_dict(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(Mapping)\ndef drop_prefix_from_dict(\nitem: Mapping[str, Any], /,\nprefix: str,\ndivider: str = '') -&gt; Mapping[str, Any]:\n\"\"\"Drops 'prefix' from keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\ncontents = {\ndrop_prefix(item = k, prefix = prefix, divider = divider): v\nfor k, v in item.items()}\nif isinstance(item, dict):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_prefix_from_list","title":"<code>drop_prefix_from_list(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(MutableSequence)\ndef drop_prefix_from_list(\nitem: MutableSequence[str], /,\nprefix: str,\ndivider: str = '') -&gt; MutableSequence[str]:\n\"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        MutableSequence[str]: modified sequence.\n    \"\"\"\ncontents = [\ndrop_prefix(item = i, prefix = prefix, divider = divider) for i in item]\nif isinstance(item, list):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_prefix_from_set","title":"<code>drop_prefix_from_set(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(AbstractSet)\ndef drop_prefix_from_set(\nitem: AbstractSet[str], /,\nprefix: str,\ndivider: str = '') -&gt; AbstractSet[str]:\n\"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\ncontents = {\ndrop_prefix(item = i, prefix = prefix, divider = divider) for i in item}\nif isinstance(item, set):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_prefix_from_str","title":"<code>drop_prefix_from_str(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register\ndef drop_prefix_from_str(item: str, /, prefix: str, divider: str = '') -&gt; str:\n\"\"\"Drops 'prefix' from 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        str: modified str.\n    \"\"\"\nprefix = ''.join([prefix, divider])\nif item.startswith(prefix):\nreturn item[len(prefix):]\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/#camina.drop_prefix_from_tuple","title":"<code>drop_prefix_from_tuple(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(tuple)\ndef drop_prefix_from_tuple(\nitem: tuple[str, ...], /,\nprefix: str,\ndivider: str = '') -&gt; tuple[str, ...]:\n\"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    \"\"\"\nreturn tuple(\n[drop_prefix(item = i, prefix = prefix, divider = divider)\nfor i in item])\n</code></pre>"},{"location":"reference/camina/#camina.drop_privates","title":"<code>drop_privates(item)</code>","text":"<p>Drops items in 'item' with names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to modify.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>item with entries dropped beginning with an underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not a registered type.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_privates(item: Any, /) -&gt; Any:\n\"\"\"Drops items in 'item' with names beginning with an underscore.\n    Args:\n        item (Any): item to modify.\n    Returns:\n        Any: item with entries dropped beginning with an underscore.\n    Raises:\n        TypeError: if 'item' is not a registered type.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.drop_privates_dict","title":"<code>drop_privates_dict(item)</code>","text":"<p>Drops items in 'item' with key names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>dict-like object with str keys that might have underscores at the beginning of the key names.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: dict-luke object with entries dropped if the key name begin with an underscore.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_privates.register(Mapping)\ndef drop_privates_dict(item: Mapping[str, Any], /) -&gt; Mapping[str, Any]:\n\"\"\"Drops items in 'item' with key names beginning with an underscore.\n    Args:\n        item (Mapping[str, Any]): dict-like object with str keys that might have\n            underscores at the beginning of the key names.\n    Returns:\n        Mapping[str, Any]: dict-luke object with entries dropped if the key name\n            begin with an underscore.\n    \"\"\"\nbase = type(item)\nreturn base({k: v for k, v in item.items() if not k.startswith('_')})\n</code></pre>"},{"location":"reference/camina/#camina.drop_privates_list","title":"<code>drop_privates_list(item)</code>","text":"<p>Drops items in 'item' with names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str | object]</code> <p>list-like object with str items or names that might have underscores at their beginnings.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str | object]</code> <p>MutableSequence[str | object]: list-like object with items dropped if they or their names begin with an underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not contain str types or objects with either 'name' or 'name' attributes.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_privates.register(MutableSequence)\ndef drop_privates_list(\nitem: MutableSequence[str | object], /) -&gt; MutableSequence[str | object]:\n\"\"\"Drops items in 'item' with names beginning with an underscore.\n    Args:\n        item (MutableSequence[str | object]): list-like object with str items or\n            names that might have underscores at their beginnings.\n    Returns:\n        MutableSequence[str | object]: list-like object with items dropped if\n            they or their names begin with an underscore.\n    Raises:\n        TypeError: if 'item' does not contain str types or objects with either\n            'name' or '__name__' attributes.\n    \"\"\"\nbase = type(item)\nif len(item) &gt; 0 and all(isinstance(i, str) for i in item):\nreturn base([i for i in item if not i.startswith('_')])\nelif len(item) &gt; 0 and all(hasattr(i, 'name') for i in item):\nreturn base([i for i in item if not i.name.startswith('_')])\nelif len(item) &gt; 0 and all(hasattr(i, '__name__') for i in item):\nreturn base([i for i in item if not i.__name__.startswith('_')])\nelif len == 0:\nreturn item\nelse:\nraise TypeError(\n'items in item must be str types or have name or __name__ '\n'attributes')\n</code></pre>"},{"location":"reference/camina/#camina.drop_substring","title":"<code>drop_substring(item, /, substring)</code>","text":"<p>Drops 'substring' from 'item' with a possible 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_substring(item: Any, /, substring: str) -&gt; Any:\n\"\"\"Drops 'substring' from 'item' with a possible 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: modified item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.drop_substring_from_dict","title":"<code>drop_substring_from_dict(item, /, substring)</code>","text":"<p>Drops 'substring' from keys in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(Mapping)\ndef drop_substring_from_dict(\nitem: Mapping[str, Any], /,\nsubstring: str) -&gt; Mapping[str, Any]:\n\"\"\"Drops 'substring' from keys in 'item'.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\ncontents = {\ndrop_substring(item = k, substring = substring): v\nfor k, v in item.items()}\nif isinstance(item, dict):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_substring_from_list","title":"<code>drop_substring_from_list(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(MutableSequence)\ndef drop_substring_from_list(\nitem: MutableSequence[str], /,\nsubstring: str) -&gt; MutableSequence[str]:\n\"\"\"Drops 'substring' from items in 'item'.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        MutableSequence[str]: modified sequence.\n    \"\"\"\ncontents = [drop_substring(item = i, substring = substring) for i in item]\nif isinstance(item, list):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_substring_from_set","title":"<code>drop_substring_from_set(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(AbstractSet)\ndef drop_substring_from_set(item: AbstractSet[str], /, substring: str) -&gt; AbstractSet[str]:\n\"\"\"Drops 'substring' from items in 'item'.\n    Args:\n        item (Set[str]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\ncontents = {drop_substring(item = i, substring = substring) for i in item}\nif isinstance(item, set):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_substring_from_str","title":"<code>drop_substring_from_str(item, /, substring)</code>","text":"<p>Drops 'substring' from 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register\ndef drop_substring_from_str(item: str, /, substring: str) -&gt; str:\n\"\"\"Drops 'substring' from 'item'.\n    Args:\n        item (str): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        str: modified str.\n    \"\"\"\nif substring in item:\nreturn item.replace(substring, '')\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/#camina.drop_substring_from_tuple","title":"<code>drop_substring_from_tuple(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(tuple)\ndef drop_substring_from_tuple(\nitem: tuple[str, ...], /,\nsubstring: str) -&gt; tuple[str, ...]:\n\"\"\"Drops 'substring' from items in 'item'.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    \"\"\"\nreturn tuple(\n[drop_substring(item = i, substring = substring) for i in item])\n</code></pre>"},{"location":"reference/camina/#camina.drop_suffix","title":"<code>drop_suffix(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_suffix(item: Any, /, suffix: str, divider: str = '') -&gt; Any:\n\"\"\"Drops 'suffix' from 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: modified item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.drop_suffix_from_dict","title":"<code>drop_suffix_from_dict(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(Mapping)\ndef drop_suffix_from_dict(\nitem: Mapping[str, Any], /,\nsuffix: str,\ndivider: str = '') -&gt; Mapping[str, Any]:\n\"\"\"Drops 'suffix' from keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\ncontents = {\ndrop_suffix(item = k, suffix = suffix, divider = divider): v\nfor k, v in item.items()}\nif isinstance(item, dict):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_suffix_from_list","title":"<code>drop_suffix_from_list(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(MutableSequence)\ndef drop_suffix_from_list(\nitem: MutableSequence[str], /,\nsuffix: str,\ndivider: str = '') -&gt; MutableSequence[str]:\n\"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        MutableSequence[str]: modified sequence.\n    \"\"\"\ncontents = [\ndrop_suffix(item = i, suffix = suffix, divider = divider) for i in item]\nif isinstance(item, list):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_suffix_from_set","title":"<code>drop_suffix_from_set(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(AbstractSet)\ndef drop_suffix_from_set(\nitem: AbstractSet[str], /,\nsuffix: str,\ndivider: str = '') -&gt; AbstractSet[str]:\n\"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\ncontents = {\ndrop_suffix(item = i, suffix = suffix, divider = divider) for i in item}\nif isinstance(item, set):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/#camina.drop_suffix_from_str","title":"<code>drop_suffix_from_str(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register\ndef drop_suffix_from_str(item: str, /, suffix: str, divider: str = '') -&gt; str:\n\"\"\"Drops 'suffix' from 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        str: modified str.\n    \"\"\"\nsuffix = ''.join([suffix, divider])\nif item.endswith(suffix):\nreturn item.removesuffix(suffix)\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/#camina.drop_suffix_from_tuple","title":"<code>drop_suffix_from_tuple(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(tuple)\ndef drop_suffix_from_tuple(\nitem: tuple[str, ...], /,\nsuffix: str,\ndivider: str = '') -&gt; tuple[str, ...]:\n\"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    \"\"\"\nreturn tuple(\n[drop_suffix(item = i, suffix = suffix, divider = divider)\nfor i in item])\n</code></pre>"},{"location":"reference/camina/#camina.hashify","title":"<code>hashify(item)</code>","text":"<p>Converts <code>item</code> to a Hashable.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a Hashable.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>Hashable</code> <code>Hashable</code> <p>derived from 'item'.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef hashify(item: Any, /) -&gt; Hashable:\n\"\"\"Converts `item` to a Hashable.\n    Args:\n        item (Any): item to convert to a Hashable.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        Hashable: derived from 'item'.\n    \"\"\"\nif isinstance(item, Hashable):\nreturn item\nelse:\ntry:\nreturn hash(item)\nexcept TypeError:\ntry:\nreturn str(item)\nexcept TypeError:\ntry:\nreturn modify.snakify(item.__name__)\nexcept AttributeError:\nreturn modify.snakify(item.__class__.__name__)\n</code></pre>"},{"location":"reference/camina/#camina.how_soon_is_now","title":"<code>how_soon_is_now(prefix=None, time_format='%Y-%m-%d_%H-%M')</code>","text":"<p>Creates a string from current date and time.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str | None</code> <p>a prefix to add to the returned str.</p> <code>None</code> <code>time_format</code> <code>str | None</code> <p>format to create a str from datetime. The passed argument should follow the rules of datetime.strftime. Defaults to '%Y-%m-%d_%H-%M'.</p> <code>'%Y-%m-%d_%H-%M'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>with current date and time in <code>time_format</code> format.</p> Source code in <code>src/camina/clock.py</code> <pre><code>def how_soon_is_now(\nprefix: str | None = None,\ntime_format: str | None = '%Y-%m-%d_%H-%M') -&gt; str:\n\"\"\"Creates a string from current date and time.\n    Args:\n        prefix: a prefix to add to the returned str.\n        time_format: format to create a str from datetime. The passed argument\n            should follow the rules of datetime.strftime. Defaults to\n            '%Y-%m-%d_%H-%M'.\n    Returns:\n        str: with current date and time in `time_format` format.\n    \"\"\"\ntime_string = convert.datetime_to_string(\nitem = datetime.datetime.now(tz_info = datetime.timezone.utc),\ntime_format = time_format)\nif prefix is not None:\nreturn f'{prefix}{time_string}'\nelse:\nreturn time_string\n</code></pre>"},{"location":"reference/camina/#camina.instancify","title":"<code>instancify(item, **kwargs)</code>","text":"<p>Returns <code>item</code> as an instance with <code>kwargs</code> as parameters/attributes.</p> <p>If <code>item</code> is already an instance, kwargs are added as attributes to the existing <code>item</code>. This will overwrite any existing attributes of the same name.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any] | object</code> <p>class to make an instance out of by passing kwargs or an instance to add kwargs to as attributes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a class nor instance.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>Any</code> <p>a class instance with <code>kwargs</code> as attributes or passed as parameters (if <code>item</code> is a class).</p> Source code in <code>src/camina/convert.py</code> <pre><code>def instancify(item: type[Any] | object, **kwargs: Any) -&gt; Any:\n\"\"\"Returns `item` as an instance with `kwargs` as parameters/attributes.\n    If `item` is already an instance, kwargs are added as attributes to the\n    existing `item`. This will overwrite any existing attributes of the same\n    name.\n    Args:\n        item (Type[Any] | object)): class to make an instance out of by\n            passing kwargs or an instance to add kwargs to as attributes.\n    Raises:\n        TypeError: if `item` is neither a class nor instance.\n    Returns:\n        object: a class instance with `kwargs` as attributes or passed as\n            parameters (if `item` is a class).\n    \"\"\"\nif inspect.isclass(item):\nreturn item(**kwargs)\nelif isinstance(item, object):\nfor key, value in kwargs.items():\nsetattr(item, key, value)\nreturn item\nelse:\nraise TypeError('item must be a class or class instance')\n</code></pre>"},{"location":"reference/camina/#camina.integerify","title":"<code>integerify(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that cannot be converted.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef integerify(item: Any, /) -&gt; int:\n\"\"\"Converts `item` to an int.\n    Args:\n        item (Any): item to convert.\n    Raises:\n        TypeError: if `item` is a type that cannot be converted.\n    Returns:\n        int: derived from `item`.\n    \"\"\"\nif isinstance(item, int):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an '\nf'unsupported type: {type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.iterify","title":"<code>iterify(item)</code>","text":"<p>Returns <code>item</code> as an iterable, but does not iterate str types.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to turn into an iterable</p> required <p>Returns:</p> Name Type Description <code>Iterable</code> <code>Iterable</code> <p>of <code>item</code>. A str type will be stored as a single item in an Iterable wrapper.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef iterify(item: Any, /) -&gt; Iterable:\n\"\"\"Returns `item` as an iterable, but does not iterate str types.\n    Args:\n        item (Any): item to turn into an iterable\n    Returns:\n        Iterable: of `item`. A str type will be stored as a single item in an\n            Iterable wrapper.\n    \"\"\"\nif item is None:\nreturn iter(())\nelif isinstance(item, (str, bytes)):\nreturn iter([item])\nelse:\ntry:\nreturn iter(item)\nexcept TypeError:\nreturn iter((item,))\n</code></pre>"},{"location":"reference/camina/#camina.kwargify","title":"<code>kwargify(item, /, args)</code>","text":"<p>Converts args to kwargs.</p> <p>item (Type): the item with annotations used to construct kwargs.     args (tuple): arguments without keywords passed to <code>item</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if there are more args than annotations in <code>item</code>.</p> <p>Returns:</p> Type Description <code>dict[Hashable, Any]</code> <p>dict[Hashable, Any]: kwargs based on <code>args</code> and <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def kwargify(item: type[Any], /, args: tuple[Any]) -&gt; dict[Hashable, Any]:\n\"\"\"Converts args to kwargs.\n    Args:\n    item (Type): the item with annotations used to construct kwargs.\n        args (tuple): arguments without keywords passed to `item`.\n    Raises:\n        ValueError: if there are more args than annotations in `item`.\n    Returns:\n        dict[Hashable, Any]: kwargs based on `args` and `item`.\n    \"\"\"\nannotations = list(item.__annotations__.keys())\nif len(args) &gt; len(annotations):\nraise ValueError('There are too many args for item')\nelse:\nreturn dict(zip(annotations, args))\n</code></pre>"},{"location":"reference/camina/#camina.listify","title":"<code>listify(item, /, default=None)</code>","text":"<p>Returns passed item as a list (if not already a list).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a list to allow proper iteration.</p> required <code>default</code> <code>Optional[Any]</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to [].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>a passed list, <code>item</code> converted to a list, or the <code>default</code> argument.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef listify(item: Any, /, default: Any | None = None) -&gt; Any:\n\"\"\"Returns passed item as a list (if not already a list).\n    Args:\n        item (Any): item to be transformed into a list to allow proper\n            iteration.\n        default (Optional[Any]): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default` is set to\n            [].\n    Returns:\n        Any: a passed list, `item` converted to a list, or the `default`\n            argument.\n    \"\"\"\nif item is None:\nif default is None:\nreturn []\nelif default in ['None', 'none']:\nreturn None\nelse:\nreturn default\nelif isinstance(item, MutableSequence) and not isinstance(item, str):\nreturn item\nelse:\nreturn [item]\n</code></pre>"},{"location":"reference/camina/#camina.namify","title":"<code>namify(item, /, default=None)</code>","text":"<p>Returns str name representation of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to determine a str name.</p> required <code>default(Optional[str])</code> <p>default name to return if other methods at name creation fail.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>a name representation of 'item.'</p> Source code in <code>src/camina/label.py</code> <pre><code>def namify(item: Any, /, default: str | None = None) -&gt; str | None:\n\"\"\"Returns str name representation of 'item'.\n    Args:\n        item (Any): item to determine a str name.\n        default(Optional[str]): default name to return if other methods at name\n            creation fail.\n    Returns:\n        str: a name representation of 'item.'\n    \"\"\"\nif isinstance(item, str):\nreturn item\nelif (\nhasattr(item, 'name')\nand not inspect.isclass(item)\nand isinstance(item.name, str)):\nreturn item.name\nelse:\ntry:\nreturn modify.snakify(item.__name__)\nexcept AttributeError:\nif item.__class__.__name__ is not None:\nreturn modify.snakify(item.__class__.__name__)\nelse:\nreturn default\n</code></pre>"},{"location":"reference/camina/#camina.numify","title":"<code>numify(item, raise_error=False)</code>","text":"<p>Converts <code>item</code> to a numeric type.</p> <p>If <code>item</code> cannot be converted to a numeric type and <code>raise_error</code> is False,     <code>item</code> is returned as is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be converted.</p> required <code>raise_error</code> <code>bool</code> <p>whether to raise a TypeError when conversion to a numeric type fails (True) or to simply return <code>item</code> (False). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> cannot be converted to a numeric type and <code>raise_error</code> is True.</p> <p>Returns:</p> Type Description <code>int | float | Any</code> <p>int | float | Any: converted to numeric type, if possible.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef numify(item: Any, raise_error: bool = False) -&gt; int | float | Any:\n\"\"\"Converts `item` to a numeric type.\n    If `item` cannot be converted to a numeric type and `raise_error` is False,\n        `item` is returned as is.\n    Args:\n        item (str): item to be converted.\n        raise_error (bool): whether to raise a TypeError when conversion to a\n            numeric type fails (True) or to simply return `item` (False).\n            Defaults to False.\n    Raises:\n        TypeError: if `item` cannot be converted to a numeric type and\n            `raise_error` is True.\n    Returns:\n        int | float | Any: converted to numeric type, if possible.\n    \"\"\"\ntry:\nreturn int(item)\nexcept ValueError:\ntry:\nreturn float(item)\nexcept ValueError:\nif raise_error:\nraise TypeError(\nf'{item} not able to be converted to a numeric type')\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/#camina.pathlibify","title":"<code>pathlibify(item)</code>","text":"<p>Converts string <code>path</code> to pathlib.Path object.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>either a string summary of a path or a pathlib.Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path object.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef pathlibify(item: str | pathlib.Path, /) -&gt; pathlib.Path:\n\"\"\"Converts string `path` to pathlib.Path object.\n    Args:\n        item (str | pathlib.Path): either a string summary of a path or a\n            pathlib.Path object.\n    Raises:\n        TypeError if `path` is neither a str or pathlib.Path type.\n    Returns:\n        pathlib.Path object.\n    \"\"\"\nif isinstance(item, str):\nreturn pathlib.Path(item)\nelif isinstance(item, pathlib.Path):\nreturn item\nelse:\nraise TypeError('item must be str or pathlib.Path type')\n</code></pre>"},{"location":"reference/camina/#camina.separate","title":"<code>separate(item, /, divider, raise_error=False)</code>","text":"<p>Divides 'item' into n+1 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide 'item' upon.</p> required <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>list[Any, ...]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef separate(\nitem: Any, /,\ndivider: Any,\nraise_error: bool = False) -&gt; tuple[Any, ...]:\n\"\"\"Divides 'item' into n+1 parts based on 'divider'.\n    Args:\n        item (Any): item to be divided.\n        divider (Any): item to divide 'item' upon.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        list[Any, ...]: parts of 'item' on either side of 'divider' unless\n            'divider' is not in 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/#camina.separate_str","title":"<code>separate_str(item, /, divider='_', raise_error=False)</code>","text":"<p>Divides 'item' into n+1 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be divided.</p> required <code>divider</code> <code>str</code> <p>item to divide 'item' upon.</p> <code>'_'</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'divider' is not in 'item' and 'raise_error' is True.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@separate.register\ndef separate_str(\nitem: str, /,\ndivider: str = '_',\nraise_error: bool = False) -&gt; list[str]:\n\"\"\"Divides 'item' into n+1 parts based on 'divider'.\n    Args:\n        item (str): item to be divided.\n        divider (str): item to divide 'item' upon.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        ValueError: if 'divider' is not in 'item' and 'raise_error' is True.\n    Returns:\n        list[str]: parts of 'item' on either side of 'divider' unless 'divider'\n            is not in 'item'.\n    \"\"\"\nif divider in item:\nreturn item.split(divider)\nelif raise_error:\nraise ValueError(f'{divider} is not in {item}')\nelse:\nreturn [item]\n</code></pre>"},{"location":"reference/camina/#camina.set_key_namer","title":"<code>set_key_namer(namer)</code>","text":"<p>Sets the global default function used to name items.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | Type[Any]], str]</code> <p>function that returns a str name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'namer' is not callable.</p> Source code in <code>src/camina/configuration.py</code> <pre><code>def set_key_namer(namer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name items.\n    Args:\n        namer (Callable[[object | Type[Any]], str]): function that returns a\n            str name of any item passed.\n    Raises:\n        TypeError: if 'namer' is not callable.\n    \"\"\"\nif isinstance(namer, Callable):\nglobals()['KEYER'] = namer\nelse:\nraise TypeError('namer argument must be a callable')\n</code></pre>"},{"location":"reference/camina/#camina.set_method_namer","title":"<code>set_method_namer(namer)</code>","text":"<p>Sets the global default function used to name factory methods.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | Type[Any]], str]</code> <p>function that returns a str name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'namer' is not callable.</p> Source code in <code>src/camina/configuration.py</code> <pre><code>def set_method_namer(namer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name factory methods.\n    Args:\n        namer (Callable[[object | Type[Any]], str]): function that returns a\n            str name of any item passed.\n    Raises:\n        TypeError: if 'namer' is not callable.\n    \"\"\"\nif isinstance(namer, Callable):\nglobals()['_METHOD_NAMER'] = namer\nelse:\nraise TypeError('namer argument must be a callable')\n</code></pre>"},{"location":"reference/camina/#camina.snakify","title":"<code>snakify(item)</code>","text":"<p>Converts a capitalized str to snake case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'item' converted to snake case.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def snakify(item: str) -&gt; str:\n\"\"\"Converts a capitalized str to snake case.\n    Args:\n        item (str): str to convert.\n    Returns:\n        str: 'item' converted to snake case.\n    \"\"\"\nitem = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', item)\nreturn re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', item).lower()\n</code></pre>"},{"location":"reference/camina/#camina.stringify","title":"<code>stringify(item, /, default=None)</code>","text":"<p>Converts <code>item</code> to a str from a Sequence.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a str from a list if it is a list.</p> required <code>default</code> <code>Any</code> <p>value to return if <code>item</code> is equivalent to a null value when passed. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not a str or list-like object.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>str, if item was a list, None or the default value if a null value was passed, or the item as it was passed if there previous two conditions don't appply.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef stringify(item: Any, /, default: Any | None = None) -&gt; Any:\n\"\"\"Converts `item` to a str from a Sequence.\n    Args:\n        item (Any): item to convert to a str from a list if it is a list.\n        default (Any): value to return if `item` is equivalent to a null\n            value when passed. Defaults to None.\n    Raises:\n        TypeError: if `item` is not a str or list-like object.\n    Returns:\n        Any: str, if item was a list, None or the default value if a null value\n            was passed, or the item as it was passed if there previous two\n            conditions don't appply.\n    \"\"\"\nif item is None:\nif default is None:\nreturn ''\nelif default in ['None', 'none']:\nreturn None\nelse:\nreturn default\nelif isinstance(item, str):\nreturn item\nelif isinstance(item, Sequence):\nreturn ', '.join(item)\nelse:\nraise TypeError('item must be str or a sequence')\n</code></pre>"},{"location":"reference/camina/#camina.timer","title":"<code>timer(process)</code>","text":"<p>Decorator for computing the length of time a process takes.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Callable[..., Any | None]</code> <p>wrapped callable to compute the time it takes to complete its execution.</p> required Source code in <code>src/camina/clock.py</code> <pre><code>def timer(\nprocess: Callable[..., Any | None]) -&gt; (Callable[..., Any | None]):\n\"\"\"Decorator for computing the length of time a process takes.\n    Args:\n        process: wrapped callable to compute the time it takes to complete its\n            execution.\n    \"\"\"\ntry:\nname = process.__name__\nexcept AttributeError:\nname = process.__class__.__name__\ndef shell_timer(operation: Callable[..., Any | None]) -&gt; (\nCallable[..., Any | None]):\ndef decorated(*args: Any, **kwargs: Any) -&gt; (\nCallable[..., Any | None]):\ndef convert_time(seconds: int | float) -&gt; tuple[int, int, int]:\nminutes, seconds = divmod(seconds, 60)\nhours, minutes = divmod(minutes, 60)\nreturn int(hours), int(minutes), int(seconds)\nimplement_time = time.time()\nresult = operation(*args, **kwargs)\ntotal_time = time.time() - implement_time\nh, m, s = convert_time(total_time)\nprint(f'{name} completed in %d:%02d:%02d' % (h, m, s))\nreturn result\nreturn decorated\nreturn shell_timer\n</code></pre>"},{"location":"reference/camina/#camina.tuplify","title":"<code>tuplify(item, /, default=None)</code>","text":"<p>Returns passed item as a tuple (if not already a tuple).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a tuple.</p> required <code>default</code> <code>Any</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to ().</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>tuple[Any]: a passed tuple, <code>item</code> converted to a tuple, or <code>default</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef tuplify(item: Any, /, default: Any | None = None) -&gt; Any:\n\"\"\"Returns passed item as a tuple (if not already a tuple).\n    Args:\n        item (Any): item to be transformed into a tuple.\n        default (Any): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default`\n            is set to ().\n    Returns:\n        tuple[Any]: a passed tuple, `item` converted to a tuple, or\n            `default`.\n    \"\"\"\nif item is None:\nif default is None:\nreturn ()\nelif default in ['None', 'none']:\nreturn None\nelse:\nreturn default\nelif isinstance(item, tuple):\nreturn item\nelif isinstance(item, Iterable):\nreturn tuple(item)\nelse:\nreturn (item,)\n</code></pre>"},{"location":"reference/camina/#camina.typify","title":"<code>typify(item)</code>","text":"<p>Converts stings to appropriate, supported datatypes.</p> <p>The method converts strings to list (if ', ' is present), int, float, or bool datatypes based upon the content of the string. If no alternative datatype is found, the item is returned in its original form.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>string to be converted to appropriate datatype.</p> required <p>Returns:</p> Type Description <code>Sequence[Any] | int | float | bool | str</code> <p>Sequence[Any] | int | float | bool | str: converted item.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def typify(item: str) -&gt; Sequence[Any] | int | float | bool | str:\n\"\"\"Converts stings to appropriate, supported datatypes.\n    The method converts strings to list (if ', ' is present), int, float,\n    or bool datatypes based upon the content of the string. If no\n    alternative datatype is found, the item is returned in its original\n    form.\n    Args:\n        item (str): string to be converted to appropriate datatype.\n    Returns:\n        Sequence[Any] | int | float | bool | str: converted item.\n    \"\"\"\nif not isinstance(item, str):\nreturn item\nelse:\ntry:\nreturn int(item)\nexcept ValueError:\ntry:\nreturn float(item)\nexcept ValueError:\nif item.lower() in ['true', 'yes']:\nreturn True\nelif item.lower() in ['false', 'no']:\nreturn False\nelif ', ' in item:\nitem = item.split(', ')\nreturn [typify(i) for i in item]\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/#camina.uniquify","title":"<code>uniquify(key, dictionary, index=1)</code>","text":"<p>Creates a unique key name to avoid overwriting an item in 'dictionary'.</p> <p>The function is 1-indexed so that the first attempt to avoid a duplicate will be: \"old_name2\".</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>name of key to test.</p> required <code>dictionary</code> <code>Mapping[Hashable, Any]</code> <p>dict for which a unique key name is sought.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>unique key name for 'dictionary'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def uniquify(\nkey: str,\ndictionary: Mapping[Hashable, Any],\nindex: int | None = 1) -&gt; str:\n\"\"\"Creates a unique key name to avoid overwriting an item in 'dictionary'.\n    The function is 1-indexed so that the first attempt to avoid a duplicate\n    will be: \"old_name2\".\n    Args:\n        key (str): name of key to test.\n        dictionary (Mapping[Hashable, Any]): dict for which a unique key name\n            is sought.\n    Returns:\n        str: unique key name for 'dictionary'.\n    \"\"\"\nif key not in dictionary:\nreturn key\nelse:\ncounter = index\nwhile True:\ncounter += 1\nif counter &gt; 2:\nname = name.removesuffix(str(counter - 1))\nname = ''.join([key, str(counter)])\nif name not in dictionary:\nreturn name\n</code></pre>"},{"location":"reference/camina/#camina.windowify","title":"<code>windowify(item, length, fill_value=None, step=1)</code>","text":"<p>Returns a sliding window of <code>length</code> over <code>item</code>.</p> <p>This code is adapted from more_itertools.windowed to remove a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Any]</code> <p>sequence from which to return windows.</p> required <code>length</code> <code>int</code> <p>length of window.</p> required <code>fill_value</code> <code>Optional[Any]</code> <p>value to use for items in a window that do not exist when length &gt; len(item). Defaults to None.</p> <code>None</code> <code>step</code> <code>Optional[Any]</code> <p>number of items to advance between each window. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>length</code> is less than 0 or step is less than 1.</p> <p>Returns:</p> Type Description <code>Sequence[Any]</code> <p>Sequence[Any]: windowed sequence derived from arguments.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def windowify(\nitem: Sequence[Any],\nlength: int,\nfill_value: Any | None = None,\nstep: int | None = 1) -&gt; Sequence[Any]:\n\"\"\"Returns a sliding window of `length` over `item`.\n    This code is adapted from more_itertools.windowed to remove a dependency.\n    Args:\n        item (Sequence[Any]): sequence from which to return windows.\n        length (int): length of window.\n        fill_value (Optional[Any]): value to use for items in a window that do\n            not exist when length &gt; len(item). Defaults to None.\n        step (Optional[Any]): number of items to advance between each window.\n            Defaults to 1.\n    Raises:\n        ValueError: if `length` is less than 0 or step is less than 1.\n    Returns:\n        Sequence[Any]: windowed sequence derived from arguments.\n    \"\"\"\nif length &lt; 0:\nraise ValueError('length must be &gt;= 0')\nif length == 0:\nyield ()\nreturn\nif step &lt; 1:\nraise ValueError('step must be &gt;= 1')\nwindow = collections.deque(maxlen = length)\ni = length\nfor _ in map(window.append, item):\ni -= 1\nif not i:\ni = step\nyield tuple(window)\nsize = len(window)\nif size &lt; length:\nyield tuple(itertools.chain(\nwindow, itertools.repeat(fill_value, length - size)))\nelif 0 &lt; i &lt; min(step, length):\nwindow += (fill_value,) * i\nyield tuple(window)\n</code></pre>"},{"location":"reference/camina/base/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> base","text":"<p>Base classes for extensible, flexible, lightweight containers</p> Contents <p>Bunch (Collection, abc.ABC): base class for general containers in <code>camina</code>.     It requires subclasses to have <code>add</code>, <code>delete</code>, and <code>subset</code> methods. Descriptor (object): interface for descriptors. <code>__get__</code>, <code>__set__</code>, and a     fully-featured <code>__set_name__</code> are provided. <code>__set_name__</code> creates     <code>attribute_name</code>, <code>owner</code>, and <code>private_name</code> attributes. Proxy (Container): basic wrapper for a stored python object. Dunder methods     attempt to intelligently apply access methods to either the wrapper or     the wrapped item.</p> To Do <p>Fix Proxy setter. In the commented out method, the wrapper and wrapped are     not being set at the right time, likely due to the inner workings of     <code>hasattr</code>. Add more dunder methods to address less common and fringe cases for use     of a Proxy class.</p>"},{"location":"reference/camina/base/#camina.base.Bunch","title":"<code>Bunch</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Collection</code>, <code>ABC</code></p> <p>Base for general <code>camina</code> collections.</p> A Bunch differs from a general python Collection in 4 ways <p>1) It must include an <code>add</code> method which provides the default mechanism     for adding new items to the collection. <code>add</code> allows a subclass to     designate the preferred method of adding to the collections<code>s stored     data without replacing other access methods. 2) It must include a</code>delete<code>method which provides the default     mechanism for deleting items in the collection.</code>delete<code>is called     by the</code>delitem<code>dunder method to delete stored items. 3) A subclass must include a</code>subset<code>method with optional</code>include<code>and</code>exclude<code>parameters for returning a subset of the Bunch subclass. 4) It supports the '+' operator being used to join a Bunch subclass     instance of the same python type (mapping, sequence, tuple, etc.).     The '+' operator calls the Bunch subclass</code>add` method to implement     how the added item(s) is/are added to the Bunch subclass instance.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Collection[Any]</code> <p>stored collection of items.</p> required"},{"location":"reference/camina/base/#camina.base.Bunch.contents","title":"<code>contents: Collection[Any]</code>  <code>instance-attribute</code>","text":"<p>Required Subclass Methods</p>"},{"location":"reference/camina/base/#camina.base.Bunch.add","title":"<code>add(item, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Adds <code>item</code> to <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to add to <code>contents</code>.</p> required <code>args</code> <code>Any</code> <p>positional arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code> Source code in <code>src/camina/base.py</code> <pre><code>@abc.abstractmethod\ndef add(self, item: Any, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Adds `item` to `contents`.\n    Args:\n        item: item to add to `contents`.\n        args: positional arguments.\n        kwargs: keyword arguments.\n    \"\"\"\n</code></pre>"},{"location":"reference/camina/base/#camina.base.Bunch.delete","title":"<code>delete(item, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Deletes <code>item</code> from <code>contents</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item or key to delete in <code>contents</code>.</p> required <code>args</code> <code>Any</code> <p>positional arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if <code>item</code> is not in <code>contents</code>. Subclasses should raise implement this error.</p> Source code in <code>src/camina/base.py</code> <pre><code>@abc.abstractmethod\ndef delete(self, item: Any, *args: Any, **kwargs: Any) -&gt; None:\n\"\"\"Deletes `item` from `contents`.\n    Args:\n        item: item or key to delete in `contents`.\n        args: positional arguments.\n        kwargs: keyword arguments.\n    Raises:\n        KeyError: if `item` is not in `contents`. Subclasses should raise\n            implement this error.\n    \"\"\"\n</code></pre>"},{"location":"reference/camina/base/#camina.base.Bunch.subset","title":"<code>subset(include=None, exclude=None, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns a new instance with a subset of <code>contents</code>.</p> <p>This method applies <code>include</code> before <code>exclude</code> if both are passed. If <code>include</code> is None, all existing items will be added to the new subset class instance before <code>exclude</code> is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Collection[Any] | Any | None</code> <p>item(s) to include in the new Bunch. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>Collection[Any] | Any | None</code> <p>item(s) to exclude from the new Bunch. Defaults to None.</p> <code>None</code> <code>args</code> <code>Any</code> <p>positional arguments.</p> <code>()</code> <code>kwargs</code> <code>Any</code> <p>keyword arguments.</p> <code>{}</code> Source code in <code>src/camina/base.py</code> <pre><code>@abc.abstractmethod\ndef subset(\nself,\ninclude: Collection[Any] | Any | None = None,\nexclude: Collection[Any] | Any | None = None,\n*args: Any,\n**kwargs: Any) -&gt; Bunch:\n\"\"\"Returns a new instance with a subset of `contents`.\n    This method applies `include` before `exclude` if both are passed. If\n    `include` is None, all existing items will be added to the new subset\n    class instance before `exclude` is applied.\n    Args:\n        include: item(s) to include in the new Bunch. Defaults to None.\n        exclude: item(s) to exclude from the new Bunch. Defaults to None.\n        args: positional arguments.\n        kwargs: keyword arguments.\n    \"\"\"\n</code></pre>"},{"location":"reference/camina/base/#camina.base.Descriptor","title":"<code>Descriptor</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Base for descriptors.</p> <p>Since Python currently lacks an abstract base class for descriptors, this class sets the basic interface for one and offers a fully-featured <code>__set_name__</code> method. Since <code>__delete__</code> isn<code>t a strict requirement for a descriptor (typical use cases simply rely on a call to</code>get`), it is not included.</p> <p>The code in this class is derived from a HowTo Guide in the official Python docs: https://docs.python.org/3/howto/descriptor.html</p> <p>Attributes:</p> Name Type Description <code>attribute_name</code> <p>name of the attribute for the Descriptor instance in <code>owner</code>.</p> <code>private_name</code> <p><code>attribute_name</code> with a leading underscore added. This attribute contains the name of an attribute in <code>owner</code> (and not the descriptor) where the data for a descriptor will be stored.</p> <code>owner</code> <p>object of which the Descriptor instance is an attribute.</p>"},{"location":"reference/camina/base/#camina.base.Proxy","title":"<code>Proxy</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Container</code></p> <p>Mostly transparent wrapper class.</p> A Proxy differs than an ordinary container in 2 significant ways <p>1) Access methods for getting, setting, and deleting that try to     intelligently direct the user's call to the proxy or stored object.     So, for example, when a user tries to set an attribute on the proxy,     the method will replace an attribute that exists in the proxy if     one exists. But if there is no such attribute, the set method is     applied to the object stored in <code>contents</code>. 2) When an <code>in</code> call is made, the <code>__contains__</code> method first looks to     see if the item is stored in <code>contents</code> (if <code>contents</code> is a     collection). If that check gets an errorr, the method then checks     if the item is equivalent to <code>contents</code>. This allows a Proxy to be     agnostic as to the type of item(s) in <code>contents</code> while returning the     expected result from an <code>in</code> call.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Any | None</code> <p>any stored item(s). Defaults to None.</p> <code>None</code> To Do <p>Add more dunder methods to address less common and fringe cases for use     of a Proxy class.</p>"},{"location":"reference/camina/base/#camina.base.Proxy.contents","title":"<code>contents: Any | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/camina/clock/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> clock","text":"<p>Date and time related tools</p> Contents <p>how_soon_is_now: returns current date and time as a str. timer: computes the time it takes for the wrapped <code>process</code> to complete.</p> To Do <p>Add mechanisms for <code>timer</code> to record results in logger and/or the python     terminal.</p>"},{"location":"reference/camina/clock/#camina.clock.how_soon_is_now","title":"<code>how_soon_is_now(prefix=None, time_format='%Y-%m-%d_%H-%M')</code>","text":"<p>Creates a string from current date and time.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str | None</code> <p>a prefix to add to the returned str.</p> <code>None</code> <code>time_format</code> <code>str | None</code> <p>format to create a str from datetime. The passed argument should follow the rules of datetime.strftime. Defaults to '%Y-%m-%d_%H-%M'.</p> <code>'%Y-%m-%d_%H-%M'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>with current date and time in <code>time_format</code> format.</p> Source code in <code>src/camina/clock.py</code> <pre><code>def how_soon_is_now(\nprefix: str | None = None,\ntime_format: str | None = '%Y-%m-%d_%H-%M') -&gt; str:\n\"\"\"Creates a string from current date and time.\n    Args:\n        prefix: a prefix to add to the returned str.\n        time_format: format to create a str from datetime. The passed argument\n            should follow the rules of datetime.strftime. Defaults to\n            '%Y-%m-%d_%H-%M'.\n    Returns:\n        str: with current date and time in `time_format` format.\n    \"\"\"\ntime_string = convert.datetime_to_string(\nitem = datetime.datetime.now(tz_info = datetime.timezone.utc),\ntime_format = time_format)\nif prefix is not None:\nreturn f'{prefix}{time_string}'\nelse:\nreturn time_string\n</code></pre>"},{"location":"reference/camina/clock/#camina.clock.timer","title":"<code>timer(process)</code>","text":"<p>Decorator for computing the length of time a process takes.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Callable[..., Any | None]</code> <p>wrapped callable to compute the time it takes to complete its execution.</p> required Source code in <code>src/camina/clock.py</code> <pre><code>def timer(\nprocess: Callable[..., Any | None]) -&gt; (Callable[..., Any | None]):\n\"\"\"Decorator for computing the length of time a process takes.\n    Args:\n        process: wrapped callable to compute the time it takes to complete its\n            execution.\n    \"\"\"\ntry:\nname = process.__name__\nexcept AttributeError:\nname = process.__class__.__name__\ndef shell_timer(operation: Callable[..., Any | None]) -&gt; (\nCallable[..., Any | None]):\ndef decorated(*args: Any, **kwargs: Any) -&gt; (\nCallable[..., Any | None]):\ndef convert_time(seconds: int | float) -&gt; tuple[int, int, int]:\nminutes, seconds = divmod(seconds, 60)\nhours, minutes = divmod(minutes, 60)\nreturn int(hours), int(minutes), int(seconds)\nimplement_time = time.time()\nresult = operation(*args, **kwargs)\ntotal_time = time.time() - implement_time\nh, m, s = convert_time(total_time)\nprint(f'{name} completed in %d:%02d:%02d' % (h, m, s))\nreturn result\nreturn decorated\nreturn shell_timer\n</code></pre>"},{"location":"reference/camina/configuration/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> configuration","text":"<p>Settings for <code>camina</code></p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/camina/configuration/#camina.configuration._MISSING_VALUE","title":"<code>_MISSING_VALUE</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Sentinel object for a missing data or parameter.</p> <p>This follows the same pattern as the <code>_MISSING_TYPE</code> class in the builtin dataclasses library. https://github.com/python/cpython/blob/3.10/Lib/dataclasses.py#L182-L186</p> <p>Because None is sometimes a valid argument or data option, this class provides an alternative that does not create the confusion that a default of None can sometimes lead to.</p>"},{"location":"reference/camina/configuration/#camina.configuration.set_key_namer","title":"<code>set_key_namer(namer)</code>","text":"<p>Sets the global default function used to name items.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | Type[Any]], str]</code> <p>function that returns a str name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'namer' is not callable.</p> Source code in <code>src/camina/configuration.py</code> <pre><code>def set_key_namer(namer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name items.\n    Args:\n        namer (Callable[[object | Type[Any]], str]): function that returns a\n            str name of any item passed.\n    Raises:\n        TypeError: if 'namer' is not callable.\n    \"\"\"\nif isinstance(namer, Callable):\nglobals()['KEYER'] = namer\nelse:\nraise TypeError('namer argument must be a callable')\n</code></pre>"},{"location":"reference/camina/configuration/#camina.configuration.set_method_namer","title":"<code>set_method_namer(namer)</code>","text":"<p>Sets the global default function used to name factory methods.</p> <p>Parameters:</p> Name Type Description Default <code>namer</code> <code>Callable[[object | Type[Any]], str]</code> <p>function that returns a str name of any item passed.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'namer' is not callable.</p> Source code in <code>src/camina/configuration.py</code> <pre><code>def set_method_namer(namer: Callable[[object | type[Any]], str]) -&gt; None:\n\"\"\"Sets the global default function used to name factory methods.\n    Args:\n        namer (Callable[[object | Type[Any]], str]): function that returns a\n            str name of any item passed.\n    Raises:\n        TypeError: if 'namer' is not callable.\n    \"\"\"\nif isinstance(namer, Callable):\nglobals()['_METHOD_NAMER'] = namer\nelse:\nraise TypeError('namer argument must be a callable')\n</code></pre>"},{"location":"reference/camina/convert/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> convert","text":"<p>Functions that convert types</p> Contents <p>dictify: converts to or validates a dict. hashify: converts to or validates a hashable object. instancify: converts to or validates an instance. If it is already an     instance, any passed kwargs are added as attributes to the instance. integerify: converts to or validates an int. iterify: converts to or validates an iterable. kwargify: uses annotations to turn positional arguments into keyword     arguments. listify: converts to or validates a list. namify: returns hashable name for passed item. numify: converts to or validates a numerical type. pathlibify: converts to or validates a pathlib.Path. stringify: converts to or validates a str. tuplify: converts to or validates a tuple. typify: converts a str type to other common types, if possible. windowify: Returns a sliding window of <code>length</code> over <code>item</code>. to_dict: to_index str_to_index to_int str_to_int float_to_int to_list str_to_list to_float int_to_float str_to_float to_path str_to_path to_str int_to_str float_to_str list_to_str none_to_str path_to_str datetime_to_str</p> To Do <p>Add more flexible tools.</p>"},{"location":"reference/camina/convert/#camina.convert.datetime_to_string","title":"<code>datetime_to_string(item, /, time_format='%Y-%m-%d_%H-%M')</code>","text":"<p>Return datetime <code>item</code> as a str based on <code>time_format</code>.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>datetime</code> <p>datetime object to convert to a str.</p> required <code>time_format</code> <code>Optional[str]</code> <p>format to create a str from datetime. The passed argument should follow the rules of datetime.strftime. Defaults to '%Y-%m-%d_%H-%M'.</p> <code>'%Y-%m-%d_%H-%M'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>converted datetime <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def datetime_to_string(\nitem: datetime.datetime, /,\ntime_format: str | None = '%Y-%m-%d_%H-%M') -&gt; str:\n\"\"\"Return datetime `item` as a str based on `time_format`.\n    Args:\n        item (datetime.datetime): datetime object to convert to a str.\n        time_format (Optional[str]): format to create a str from datetime. The\n            passed argument should follow the rules of datetime.strftime.\n            Defaults to '%Y-%m-%d_%H-%M'.\n    Returns:\n        str: converted datetime `item`.\n    \"\"\"\nreturn item.strftime(time_format)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.dictify","title":"<code>dictify(item)</code>","text":"<p>Converts <code>item</code> to a MutableMapping.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a MutableMapping.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>MutableMapping</code> <code>MutableMapping[Hashable, Any]</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef dictify(item: Any, /) -&gt; MutableMapping[Hashable, Any]:\n\"\"\"Converts `item` to a MutableMapping.\n    Args:\n        item: item to convert to a MutableMapping.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        MutableMapping: derived from `item`.\n    \"\"\"\nif isinstance(item, MutableMapping):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an unsupported type: '\nf'{type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.float_to_int","title":"<code>float_to_int(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>float</code> <p>item to convert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@integerify.register\ndef float_to_int(item: float, /) -&gt; int:\n\"\"\"Converts `item` to an int.\n    Args:\n        item (float): item to convert.\n    Returns:\n        int: derived from `item`.\n    \"\"\"\nreturn int(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.float_to_str","title":"<code>float_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>float</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def float_to_str(item: float, /) -&gt; str:\n\"\"\"[summary]\n    Args:\n        item (float): [description]\n    Returns:\n        str: [description]\n    \"\"\"\n\"\"\"Converts an float to a str.\"\"\"\nreturn str(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.hashify","title":"<code>hashify(item)</code>","text":"<p>Converts <code>item</code> to a Hashable.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a Hashable.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>Hashable</code> <code>Hashable</code> <p>derived from 'item'.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef hashify(item: Any, /) -&gt; Hashable:\n\"\"\"Converts `item` to a Hashable.\n    Args:\n        item (Any): item to convert to a Hashable.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        Hashable: derived from 'item'.\n    \"\"\"\nif isinstance(item, Hashable):\nreturn item\nelse:\ntry:\nreturn hash(item)\nexcept TypeError:\ntry:\nreturn str(item)\nexcept TypeError:\ntry:\nreturn modify.snakify(item.__name__)\nexcept AttributeError:\nreturn modify.snakify(item.__class__.__name__)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.instancify","title":"<code>instancify(item, **kwargs)</code>","text":"<p>Returns <code>item</code> as an instance with <code>kwargs</code> as parameters/attributes.</p> <p>If <code>item</code> is already an instance, kwargs are added as attributes to the existing <code>item</code>. This will overwrite any existing attributes of the same name.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any] | object</code> <p>class to make an instance out of by passing kwargs or an instance to add kwargs to as attributes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is neither a class nor instance.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>Any</code> <p>a class instance with <code>kwargs</code> as attributes or passed as parameters (if <code>item</code> is a class).</p> Source code in <code>src/camina/convert.py</code> <pre><code>def instancify(item: type[Any] | object, **kwargs: Any) -&gt; Any:\n\"\"\"Returns `item` as an instance with `kwargs` as parameters/attributes.\n    If `item` is already an instance, kwargs are added as attributes to the\n    existing `item`. This will overwrite any existing attributes of the same\n    name.\n    Args:\n        item (Type[Any] | object)): class to make an instance out of by\n            passing kwargs or an instance to add kwargs to as attributes.\n    Raises:\n        TypeError: if `item` is neither a class nor instance.\n    Returns:\n        object: a class instance with `kwargs` as attributes or passed as\n            parameters (if `item` is a class).\n    \"\"\"\nif inspect.isclass(item):\nreturn item(**kwargs)\nelif isinstance(item, object):\nfor key, value in kwargs.items():\nsetattr(item, key, value)\nreturn item\nelse:\nraise TypeError('item must be a class or class instance')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.int_to_float","title":"<code>int_to_float(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def int_to_float(item: int, /) -&gt; float:\n\"\"\"[summary]\n    Args:\n        item (int): [description]\n    Returns:\n        float: [description]\n    \"\"\"\n\"\"\"Converts an int to a float.\"\"\"\nreturn float(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.int_to_str","title":"<code>int_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>int</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def int_to_str(item: int, /) -&gt; str:\n\"\"\"[summary]\n    Args:\n        item (int): [description]\n    Returns:\n        str: [description]\n    \"\"\"\n\"\"\"Converts an int to a str.\"\"\"\nreturn str(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.integerify","title":"<code>integerify(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that cannot be converted.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef integerify(item: Any, /) -&gt; int:\n\"\"\"Converts `item` to an int.\n    Args:\n        item (Any): item to convert.\n    Raises:\n        TypeError: if `item` is a type that cannot be converted.\n    Returns:\n        int: derived from `item`.\n    \"\"\"\nif isinstance(item, int):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an '\nf'unsupported type: {type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.iterify","title":"<code>iterify(item)</code>","text":"<p>Returns <code>item</code> as an iterable, but does not iterate str types.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to turn into an iterable</p> required <p>Returns:</p> Name Type Description <code>Iterable</code> <code>Iterable</code> <p>of <code>item</code>. A str type will be stored as a single item in an Iterable wrapper.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef iterify(item: Any, /) -&gt; Iterable:\n\"\"\"Returns `item` as an iterable, but does not iterate str types.\n    Args:\n        item (Any): item to turn into an iterable\n    Returns:\n        Iterable: of `item`. A str type will be stored as a single item in an\n            Iterable wrapper.\n    \"\"\"\nif item is None:\nreturn iter(())\nelif isinstance(item, (str, bytes)):\nreturn iter([item])\nelse:\ntry:\nreturn iter(item)\nexcept TypeError:\nreturn iter((item,))\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.kwargify","title":"<code>kwargify(item, /, args)</code>","text":"<p>Converts args to kwargs.</p> <p>item (Type): the item with annotations used to construct kwargs.     args (tuple): arguments without keywords passed to <code>item</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if there are more args than annotations in <code>item</code>.</p> <p>Returns:</p> Type Description <code>dict[Hashable, Any]</code> <p>dict[Hashable, Any]: kwargs based on <code>args</code> and <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def kwargify(item: type[Any], /, args: tuple[Any]) -&gt; dict[Hashable, Any]:\n\"\"\"Converts args to kwargs.\n    Args:\n    item (Type): the item with annotations used to construct kwargs.\n        args (tuple): arguments without keywords passed to `item`.\n    Raises:\n        ValueError: if there are more args than annotations in `item`.\n    Returns:\n        dict[Hashable, Any]: kwargs based on `args` and `item`.\n    \"\"\"\nannotations = list(item.__annotations__.keys())\nif len(args) &gt; len(annotations):\nraise ValueError('There are too many args for item')\nelse:\nreturn dict(zip(annotations, args))\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.list_to_str","title":"<code>list_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>list[Any]</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def list_to_str(item: list[Any], /) -&gt; str:\n\"\"\"[summary]\n    Args:\n        item (list[Any]): [description]\n    Returns:\n        str: [description]\n    \"\"\"\n\"\"\"Converts a list to a str.\"\"\"\nreturn ', '.join(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.listify","title":"<code>listify(item, /, default=None)</code>","text":"<p>Returns passed item as a list (if not already a list).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a list to allow proper iteration.</p> required <code>default</code> <code>Optional[Any]</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to [].</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>a passed list, <code>item</code> converted to a list, or the <code>default</code> argument.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef listify(item: Any, /, default: Any | None = None) -&gt; Any:\n\"\"\"Returns passed item as a list (if not already a list).\n    Args:\n        item (Any): item to be transformed into a list to allow proper\n            iteration.\n        default (Optional[Any]): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default` is set to\n            [].\n    Returns:\n        Any: a passed list, `item` converted to a list, or the `default`\n            argument.\n    \"\"\"\nif item is None:\nif default is None:\nreturn []\nelif default in ['None', 'none']:\nreturn None\nelse:\nreturn default\nelif isinstance(item, MutableSequence) and not isinstance(item, str):\nreturn item\nelse:\nreturn [item]\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.none_to_str","title":"<code>none_to_str(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>None</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def none_to_str(item: None, /) -&gt; str:\n\"\"\"[summary]\n    Args:\n        item (None): [description]\n    Returns:\n        str: [description]\n    \"\"\"\n\"\"\"Converts None to a str.\"\"\"\nreturn 'None'\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.numify","title":"<code>numify(item, raise_error=False)</code>","text":"<p>Converts <code>item</code> to a numeric type.</p> <p>If <code>item</code> cannot be converted to a numeric type and <code>raise_error</code> is False,     <code>item</code> is returned as is.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be converted.</p> required <code>raise_error</code> <code>bool</code> <p>whether to raise a TypeError when conversion to a numeric type fails (True) or to simply return <code>item</code> (False). Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> cannot be converted to a numeric type and <code>raise_error</code> is True.</p> <p>Returns:</p> Type Description <code>int | float | Any</code> <p>int | float | Any: converted to numeric type, if possible.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef numify(item: Any, raise_error: bool = False) -&gt; int | float | Any:\n\"\"\"Converts `item` to a numeric type.\n    If `item` cannot be converted to a numeric type and `raise_error` is False,\n        `item` is returned as is.\n    Args:\n        item (str): item to be converted.\n        raise_error (bool): whether to raise a TypeError when conversion to a\n            numeric type fails (True) or to simply return `item` (False).\n            Defaults to False.\n    Raises:\n        TypeError: if `item` cannot be converted to a numeric type and\n            `raise_error` is True.\n    Returns:\n        int | float | Any: converted to numeric type, if possible.\n    \"\"\"\ntry:\nreturn int(item)\nexcept ValueError:\ntry:\nreturn float(item)\nexcept ValueError:\nif raise_error:\nraise TypeError(\nf'{item} not able to be converted to a numeric type')\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.path_to_str","title":"<code>path_to_str(item)</code>","text":"<p>Converts a pathlib.Path to a str.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Path</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def path_to_str(item: pathlib.Path, /) -&gt; str:\n\"\"\"Converts a pathlib.Path to a str.\n    Args:\n        item (pathlib.Path): [description]\n    Returns:\n        str: [description]\n    \"\"\"\nreturn str(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.pathlibify","title":"<code>pathlibify(item)</code>","text":"<p>Converts string <code>path</code> to pathlib.Path object.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | Path</code> <p>either a string summary of a path or a pathlib.Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path object.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef pathlibify(item: str | pathlib.Path, /) -&gt; pathlib.Path:\n\"\"\"Converts string `path` to pathlib.Path object.\n    Args:\n        item (str | pathlib.Path): either a string summary of a path or a\n            pathlib.Path object.\n    Raises:\n        TypeError if `path` is neither a str or pathlib.Path type.\n    Returns:\n        pathlib.Path object.\n    \"\"\"\nif isinstance(item, str):\nreturn pathlib.Path(item)\nelif isinstance(item, pathlib.Path):\nreturn item\nelse:\nraise TypeError('item must be str or pathlib.Path type')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.str_to_float","title":"<code>str_to_float(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>[description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def str_to_float(item: str, /) -&gt; float:\n\"\"\"[summary]\n    Args:\n        item (str): [description]\n    Returns:\n        float: [description]\n    \"\"\"\n\"\"\"Converts a str to a float.\"\"\"\nreturn float(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.str_to_int","title":"<code>str_to_int(item)</code>","text":"<p>Converts <code>item</code> to an int.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to convert.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@integerify.register\ndef str_to_int(item: str, /) -&gt; int:\n\"\"\"Converts `item` to an int.\n    Args:\n        item (str): item to convert.\n    Returns:\n        int: derived from `item`.\n    \"\"\"\nreturn int(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.str_to_list","title":"<code>str_to_list(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: [description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>def str_to_list(item: str, /) -&gt; list[Any]:\n\"\"\"[summary]\n    Args:\n        item (str): [description]\n    Returns:\n        list[Any]: [description]\n    \"\"\"\n\"\"\"Converts a str to a list.\"\"\"\nreturn ast.literal_eval(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.str_to_path","title":"<code>str_to_path(item)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: [description]</p> Source code in <code>src/camina/convert.py</code> <pre><code>@pathlibify.register\ndef str_to_path(item: str, /) -&gt; pathlib.Path:\n\"\"\"[summary]\n    Args:\n        item (str): [description]\n    Returns:\n        pathlib.Path: [description]\n    \"\"\"\n\"\"\"Converts a str to a pathlib.Path.\"\"\"\nreturn pathlib.pathlib.Path(item)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.stringify","title":"<code>stringify(item, /, default=None)</code>","text":"<p>Converts <code>item</code> to a str from a Sequence.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a str from a list if it is a list.</p> required <code>default</code> <code>Any</code> <p>value to return if <code>item</code> is equivalent to a null value when passed. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is not a str or list-like object.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>str, if item was a list, None or the default value if a null value was passed, or the item as it was passed if there previous two conditions don't appply.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef stringify(item: Any, /, default: Any | None = None) -&gt; Any:\n\"\"\"Converts `item` to a str from a Sequence.\n    Args:\n        item (Any): item to convert to a str from a list if it is a list.\n        default (Any): value to return if `item` is equivalent to a null\n            value when passed. Defaults to None.\n    Raises:\n        TypeError: if `item` is not a str or list-like object.\n    Returns:\n        Any: str, if item was a list, None or the default value if a null value\n            was passed, or the item as it was passed if there previous two\n            conditions don't appply.\n    \"\"\"\nif item is None:\nif default is None:\nreturn ''\nelif default in ['None', 'none']:\nreturn None\nelse:\nreturn default\nelif isinstance(item, str):\nreturn item\nelif isinstance(item, Sequence):\nreturn ', '.join(item)\nelse:\nraise TypeError('item must be str or a sequence')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.to_float","title":"<code>to_float(item)</code>","text":"<p>Converts <code>item</code> to a float.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a float.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def to_float(item: Any, /) -&gt; float:\n\"\"\"Converts `item` to a float.\n    Args:\n        item (Any): item to convert to a float.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        float: derived from `item`.\n    \"\"\"\nif isinstance(item, float):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an unsupported type: '\nf'{type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.to_list","title":"<code>to_list(item)</code>","text":"<p>Converts <code>item</code> to a list.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a list.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Type Description <code>list[Any]</code> <p>list[Any]: derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def to_list(item: Any, /) -&gt; list[Any]:\n\"\"\"Converts `item` to a list.\n    Args:\n        item (Any): item to convert to a list.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        list[Any]: derived from `item`.\n    \"\"\"\nif isinstance(item, list[Any]):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an unsupported type: '\nf'{type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.to_path","title":"<code>to_path(item)</code>","text":"<p>Converts <code>item</code> to a pathlib.Path.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a pathlib.Path.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Type Description <code>Path</code> <p>pathlib.Path: derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def to_path(item: Any, /) -&gt; pathlib.Path:\n\"\"\"Converts `item` to a pathlib.Path.\n    Args:\n        item (Any): item to convert to a pathlib.Path.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        pathlib.Path: derived from `item`.\n    \"\"\"\nif isinstance(item, pathlib.Path):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an unsupported type: '\nf'{type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.to_str","title":"<code>to_str(item)</code>","text":"<p>Converts <code>item</code> to a str.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to convert to a str.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>item</code> is a type that is not registered.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>derived from <code>item</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def to_str(item: Any, /) -&gt; str:\n\"\"\"Converts `item` to a str.\n    Args:\n        item (Any): item to convert to a str.\n    Raises:\n        TypeError: if `item` is a type that is not registered.\n    Returns:\n        str: derived from `item`.\n    \"\"\"\nif isinstance(item, str):\nreturn item\nelse:\nraise TypeError(\nf'item cannot be converted because it is an unsupported type: '\nf'{type(item).__name__}')\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.tuplify","title":"<code>tuplify(item, /, default=None)</code>","text":"<p>Returns passed item as a tuple (if not already a tuple).</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be transformed into a tuple.</p> required <code>default</code> <code>Any</code> <p>the default value to return if <code>item</code> is None. Unfortunately, to indicate you want None to be the default value, you need to put <code>None</code> in quotes. If not passed, <code>default</code> is set to ().</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>tuple[Any]: a passed tuple, <code>item</code> converted to a tuple, or <code>default</code>.</p> Source code in <code>src/camina/convert.py</code> <pre><code>@functools.singledispatch\ndef tuplify(item: Any, /, default: Any | None = None) -&gt; Any:\n\"\"\"Returns passed item as a tuple (if not already a tuple).\n    Args:\n        item (Any): item to be transformed into a tuple.\n        default (Any): the default value to return if `item` is None.\n            Unfortunately, to indicate you want None to be the default value,\n            you need to put `None` in quotes. If not passed, `default`\n            is set to ().\n    Returns:\n        tuple[Any]: a passed tuple, `item` converted to a tuple, or\n            `default`.\n    \"\"\"\nif item is None:\nif default is None:\nreturn ()\nelif default in ['None', 'none']:\nreturn None\nelse:\nreturn default\nelif isinstance(item, tuple):\nreturn item\nelif isinstance(item, Iterable):\nreturn tuple(item)\nelse:\nreturn (item,)\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.typify","title":"<code>typify(item)</code>","text":"<p>Converts stings to appropriate, supported datatypes.</p> <p>The method converts strings to list (if ', ' is present), int, float, or bool datatypes based upon the content of the string. If no alternative datatype is found, the item is returned in its original form.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>string to be converted to appropriate datatype.</p> required <p>Returns:</p> Type Description <code>Sequence[Any] | int | float | bool | str</code> <p>Sequence[Any] | int | float | bool | str: converted item.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def typify(item: str) -&gt; Sequence[Any] | int | float | bool | str:\n\"\"\"Converts stings to appropriate, supported datatypes.\n    The method converts strings to list (if ', ' is present), int, float,\n    or bool datatypes based upon the content of the string. If no\n    alternative datatype is found, the item is returned in its original\n    form.\n    Args:\n        item (str): string to be converted to appropriate datatype.\n    Returns:\n        Sequence[Any] | int | float | bool | str: converted item.\n    \"\"\"\nif not isinstance(item, str):\nreturn item\nelse:\ntry:\nreturn int(item)\nexcept ValueError:\ntry:\nreturn float(item)\nexcept ValueError:\nif item.lower() in ['true', 'yes']:\nreturn True\nelif item.lower() in ['false', 'no']:\nreturn False\nelif ', ' in item:\nitem = item.split(', ')\nreturn [typify(i) for i in item]\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/convert/#camina.convert.windowify","title":"<code>windowify(item, length, fill_value=None, step=1)</code>","text":"<p>Returns a sliding window of <code>length</code> over <code>item</code>.</p> <p>This code is adapted from more_itertools.windowed to remove a dependency.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Sequence[Any]</code> <p>sequence from which to return windows.</p> required <code>length</code> <code>int</code> <p>length of window.</p> required <code>fill_value</code> <code>Optional[Any]</code> <p>value to use for items in a window that do not exist when length &gt; len(item). Defaults to None.</p> <code>None</code> <code>step</code> <code>Optional[Any]</code> <p>number of items to advance between each window. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>length</code> is less than 0 or step is less than 1.</p> <p>Returns:</p> Type Description <code>Sequence[Any]</code> <p>Sequence[Any]: windowed sequence derived from arguments.</p> Source code in <code>src/camina/convert.py</code> <pre><code>def windowify(\nitem: Sequence[Any],\nlength: int,\nfill_value: Any | None = None,\nstep: int | None = 1) -&gt; Sequence[Any]:\n\"\"\"Returns a sliding window of `length` over `item`.\n    This code is adapted from more_itertools.windowed to remove a dependency.\n    Args:\n        item (Sequence[Any]): sequence from which to return windows.\n        length (int): length of window.\n        fill_value (Optional[Any]): value to use for items in a window that do\n            not exist when length &gt; len(item). Defaults to None.\n        step (Optional[Any]): number of items to advance between each window.\n            Defaults to 1.\n    Raises:\n        ValueError: if `length` is less than 0 or step is less than 1.\n    Returns:\n        Sequence[Any]: windowed sequence derived from arguments.\n    \"\"\"\nif length &lt; 0:\nraise ValueError('length must be &gt;= 0')\nif length == 0:\nyield ()\nreturn\nif step &lt; 1:\nraise ValueError('step must be &gt;= 1')\nwindow = collections.deque(maxlen = length)\ni = length\nfor _ in map(window.append, item):\ni -= 1\nif not i:\ni = step\nyield tuple(window)\nsize = len(window)\nif size &lt; length:\nyield tuple(itertools.chain(\nwindow, itertools.repeat(fill_value, length - size)))\nelif 0 &lt; i &lt; min(step, length):\nwindow += (fill_value,) * i\nyield tuple(window)\n</code></pre>"},{"location":"reference/camina/label/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> label","text":"<p>System and functions for inferring object and class names</p> <p>Contents:</p> <p>To Do:</p>"},{"location":"reference/camina/label/#camina.label.Name","title":"<code>Name</code>  <code>dataclass</code>","text":"<p>             Bases: <code>object</code></p> <p>Descriptor for a name attribute.</p> <p>This class automatically provides a name attribute to an object using the '_KEY_NAMER' function.</p> <p>Parameters:</p> Name Type Description Default <code>_KEY_NAMER</code> <code>Optional[Callable[[object | Type[Any]], str]]</code> <p>function that creates a name if one has not been stored. Defaults to namify.</p> <code>namify</code> <p>Attributes:</p> Name Type Description <code>private_name</code> <code>str</code> <p>the name of the attribute in the owner instance with a leading underscore added.</p>"},{"location":"reference/camina/label/#camina.label.Name._KEY_NAMER","title":"<code>_KEY_NAMER: Callable[[object | type[Any]], str] | None = namify</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Dunder Methods</p>"},{"location":"reference/camina/label/#camina.label.namify","title":"<code>namify(item, /, default=None)</code>","text":"<p>Returns str name representation of 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to determine a str name.</p> required <code>default(Optional[str])</code> <p>default name to return if other methods at name creation fail.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str | None</code> <p>a name representation of 'item.'</p> Source code in <code>src/camina/label.py</code> <pre><code>def namify(item: Any, /, default: str | None = None) -&gt; str | None:\n\"\"\"Returns str name representation of 'item'.\n    Args:\n        item (Any): item to determine a str name.\n        default(Optional[str]): default name to return if other methods at name\n            creation fail.\n    Returns:\n        str: a name representation of 'item.'\n    \"\"\"\nif isinstance(item, str):\nreturn item\nelif (\nhasattr(item, 'name')\nand not inspect.isclass(item)\nand isinstance(item.name, str)):\nreturn item.name\nelse:\ntry:\nreturn modify.snakify(item.__name__)\nexcept AttributeError:\nif item.__class__.__name__ is not None:\nreturn modify.snakify(item.__class__.__name__)\nelse:\nreturn default\n</code></pre>"},{"location":"reference/camina/mapping/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mapping","text":"<p>Extensible, flexible, lightweight dict-like classes</p> Contents <p>Dictionary (base.Bunch, MutableMapping): drop-in replacement for a python     dict with some added functionality. Catalog (Dictionary): wildcard-accepting dict which is primarily intended     for storing different options and strategies. It also returns lists of     matches if a list of keys is provided. ChainDictionary (Dictionary): combines the additional functionality of     Dictionary with collections.ChainMap from the Python builtin library. Repository (Dictionary): stores items using inferred keys when the 'add'     method is called. This is useful for mappings where the key naming is     controlled by the mapping instead of based on the passed arguments.     Support for guaranteed unique key creation (using an integer counter) is     provided out of the box based on the 'overwrite' argument.</p> <p>To Do:</p>"},{"location":"reference/camina/mapping/#camina.mapping.Catalog","title":"<code>Catalog</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dictionary</code></p> <p>Wildcard and list-accepting dictionary.</p> <p>A Catalog inherits the differences between a Dictionary and an ordinary python dict.</p> A Catalog differs from a Dictionary in 5 significant ways <p>1) It recognizes an 'all' key which will return a list of all values     stored in a Catalog instance. 2) It recognizes a 'default' key which will return all values matching     keys listed in the 'default' attribute. 'default' can also be set     using the 'catalog['default'] = new_default' assignment. If     'default' is not passed when the instance is initialized, the     initial value of 'default' is 'all'. 3) It recognizes a 'none' key which will return an empty list. 4) It supports a list of keys being accessed with the matching values     returned. For example, 'catalog[['first_key', 'second_key']]' will     return the values for those keys in a list ['first_value',     'second_value']. 5) If a single key is sought, a Catalog can either return the stored     value or a stored value in a list (if 'always_return_list' is     True). The latter option is available to make iteration easier     when the iterator assumes a single type will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>Mapping[Hashable, Any]]</code> <p>stored dictionary. Defaults to an empty dict.</p> <code>field(default_factory=dict)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code> <code>default</code> <code>Optional[Any]]</code> <p>a list of keys in 'contents' which will be used to return items when 'default' is sought. If not passed, 'default' will be set to all keys.</p> <code>'all'</code> <code>always_return_list</code> <code>bool</code> <p>whether to return a list even when the key passed is not a list or special access key (True) or to return a list only when a list or special access key is used (False). Defaults to False.</p> <code>False</code>"},{"location":"reference/camina/mapping/#camina.mapping.Catalog.always_return_list","title":"<code>always_return_list: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/mapping/#camina.mapping.Catalog.delete","title":"<code>delete(item)</code>","text":"<p>Deletes 'item' in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable | Sequence[Hashable]</code> <p>name(s) of key(s) in 'contents' to delete the key/value pair.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def delete(self, item: Hashable | Sequence[Hashable]) -&gt; None:\n\"\"\"Deletes 'item' in 'contents'.\n    Args:\n        item (Hashable | Sequence[Hashable]): name(s) of key(s) in\n            'contents' to delete the key/value pair.\n    \"\"\"\nkeys = list(convert.iterify(item))\nif all(k in self for k in keys):\nself.contents = {\ni: self.contents[i] for i in self.contents if i not in keys}\nelse:\nraise KeyError(f'{item} not found in the Catalog')\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary","title":"<code>ChainDictionary</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dictionary</code></p> <p>Combines functionality of collections.ChainMap with Dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Dictionary[Hashable, Any]]</code> <p>list of stored Dictionary instances. This is equivalent to the 'maps' attribute of a collections.ChainMap instance but uses a different name for compatibility with base.Bunch. A separate 'maps' property is included which points to 'contents' to ensure compatibility in the opposite direction.</p> <code>field(default_factory=list)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code> <code>return_first</code> <code>Optional[bool]</code> <p>whether to only return the first match found (True) or to search all of the stored Dictionary instances (False). Defaults to True.</p> <code>True</code>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.maps","title":"<code>maps: MutableSequence[Dictionary[Hashable, Any]]</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>Returns 'contents' attribute.</p> <p>Returns:</p> Type Description <code>MutableSequence[Dictionary[Hashable, Any]]</code> <p>MutableSequence[Dictionary[Hashable, Any]]: stored Dictionary instances.</p>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.return_first","title":"<code>return_first: bool | None = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Properties</p>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.add","title":"<code>add(item, **kwargs)</code>","text":"<p>Adds 'item' to the 'contents' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[Hashable, Any]</code> <p>items to add to 'contents' attribute.</p> required <code>kwargs</code> <code>Any</code> <p>creates a consistent interface even when subclasses have additional parameters.</p> <code>{}</code> Source code in <code>src/camina/mapping.py</code> <pre><code>def add(self, item: Mapping[Hashable, Any], **kwargs: Any) -&gt; None:\n\"\"\"Adds 'item' to the 'contents' attribute.\n    Args:\n        item (Mapping[Hashable, Any]): items to add to 'contents' attribute.\n        kwargs: creates a consistent interface even when subclasses have\n            additional parameters.\n    \"\"\"\nself.contents.append(item, **kwargs)\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.delete","title":"<code>delete(item)</code>","text":"<p>Deletes 'item' in 'contents'.</p> <p>Because a chained mapping can have identical keys in different stored mappings, this method searches through all of the stored Dictionary instances and removes the key wherever it appears.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key in 'contents' to delete the key/value pair.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def delete(self, item: Hashable) -&gt; None:\n\"\"\"Deletes 'item' in 'contents'.\n    Because a chained mapping can have identical keys in different stored\n    mappings, this method searches through all of the stored Dictionary\n    instances and removes the key wherever it appears.\n    Args:\n        item (Hashable): key in 'contents' to delete the key/value pair.\n    \"\"\"\nfor dictionary in self.contents:\nwith contextlib.suppress(KeyError):\ndel dictionary[item]\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.fromkeys","title":"<code>fromkeys(keys, value, **kwargs)</code>  <code>classmethod</code>","text":"<p>Emulates the 'fromkeys' class method from a python dict.</p> <p>Since this method is an awkward fit with a chained map, it just assigns the 'keys' and 'value' to a single Dictionary stored in the 'contents' list.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[Hashable]</code> <p>items to be keys in a new Dictionary.</p> required <code>value</code> <code>Any</code> <p>the value to use for all values in a new Dictionary.</p> required <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>Dictionary</code> <p>formed from 'keys' and 'value'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>@classmethod\ndef fromkeys(\ncls,\nkeys: Sequence[Hashable],\nvalue: Any,\n**kwargs: Any) -&gt; Dictionary:\n\"\"\"Emulates the 'fromkeys' class method from a python dict.\n    Since this method is an awkward fit with a chained map, it just assigns\n    the 'keys' and 'value' to a single Dictionary stored in the 'contents'\n    list.\n    Args:\n        keys (Sequence[Hashable]): items to be keys in a new Dictionary.\n        value (Any): the value to use for all values in a new Dictionary.\n    Returns:\n        Dictionary: formed from 'keys' and 'value'.\n    \"\"\"\nreturn cls(contents = [Dictionary.fromkeys(keys, value, **kwargs)])\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.items","title":"<code>items()</code>","text":"<p>Emulates python dict 'items' method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, Any], ...]</code> <p>tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, Any], ...]:\n\"\"\"Emulates python dict 'items' method.\n    Returns:\n        tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values()))\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.keys","title":"<code>keys()</code>","text":"<p>Returns 'contents' keys as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>tuple[Hashable, ...]: a tuple equivalent to dict.keys().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Returns 'contents' keys as a tuple.\n    Returns:\n        tuple[Hashable, ...]: a tuple equivalent to dict.keys().\n    \"\"\"\nreturn tuple(\nitertools.chain.from_iterable([d.keys() for d in self.contents]))\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.new_child","title":"<code>new_child(m, **kwargs)</code>","text":"<p>Inserts 'm' as the first Dictionary in 'contents'.</p> <p>This method mirrors the functionality and parameters of collections.Chainmap.new_child.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Dictionary</code> <p>new Dictionary to add to 'contents' at index 0.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def new_child(self, m: Dictionary, **kwargs) -&gt; None:\n\"\"\"Inserts 'm' as the first Dictionary in 'contents'.\n    This method mirrors the functionality and parameters of\n    collections.Chainmap.new_child.\n    Args:\n        m (Dictionary): new Dictionary to add to 'contents' at index 0.\n    \"\"\"\nself.contents.insert(0, m)\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.parents","title":"<code>parents()</code>","text":"<p>Returns an instance with 'contents' after the first.</p> <p>This method mirrors the functionality of collections.Chainmap.parents.</p> <p>Returns:</p> Name Type Description <code>ChainDictionary</code> <code>ChainDictionary</code> <p>an isntance with all stored Dictionary instances after the first.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def parents(self) -&gt; ChainDictionary:\n\"\"\"Returns an instance with 'contents' after the first.\n    This method mirrors the functionality of collections.Chainmap.parents.\n    Returns:\n        ChainDictionary: an isntance with all stored Dictionary instances\n            after the first.\n    \"\"\"\nreturn self.__class__(\nself.contents[1:],\ndefault_factory = self.default_factory)\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of 'contents'.</p> <p>This method applies 'include' before 'exclude' if both are passed. If 'include' is None, all existing items will be added to the new subset class instance before 'exclude' is applied.</p> <p>This method relies on all stored mappings being compatible with the Dictionary class because it uses the 'subset' method of those stored mappings.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to include in the new Dictionary instance.</p> <code>None</code> <code>exclude</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to exclude from the new Dictionary instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'include' and 'exclude' are both None.</p> <p>Returns:</p> Name Type Description <code>ChainDictionary</code> <code>ChainDictionary</code> <p>with only keys from 'include' and no keys in 'exclude'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def subset(\nself,\ninclude: Hashable | Sequence[Hashable] | None = None,\nexclude: Hashable | Sequence[Hashable] | None = None) -&gt; (\nChainDictionary):\n\"\"\"Returns a new instance with a subset of 'contents'.\n    This method applies 'include' before 'exclude' if both are passed. If\n    'include' is None, all existing items will be added to the new subset\n    class instance before 'exclude' is applied.\n    This method relies on all stored mappings being compatible with the\n    Dictionary class because it uses the 'subset' method of those stored\n    mappings.\n    Args:\n        include (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            include in the new Dictionary instance.\n        exclude (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            exclude from the new Dictionary instance.\n    Raises:\n        ValueError: if 'include' and 'exclude' are both None.\n    Returns:\n        ChainDictionary: with only keys from 'include' and no keys in\n            'exclude'.\n    \"\"\"\nnew_contents = []\nfor dictionary in self.contents:\nnew_contents.append(\ndictionary.subset(include = include, exclude = exclude))\nnew_dictionary = copy.deepcopy(self)\nnew_dictionary.contents = new_contents\nreturn new_dictionary\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.ChainDictionary.values","title":"<code>values()</code>","text":"<p>Returns 'contents' values as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: a tuple equivalent to dict.values().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Returns 'contents' values as a tuple.\n    Returns:\n        tuple[Any, ...]: a tuple equivalent to dict.values().\n    \"\"\"\nreturn tuple(\nitertools.chain.from_iterable([d.values() for d in self.contents]))\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary","title":"<code>Dictionary</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Bunch</code>, <code>MutableMapping</code></p> <p>Basic camina dict replacement.</p> <p>A Dictionary differs from an ordinary python dict in ways inherited from Bunch by requiring 'add' and 'subset' methods, storing data in 'contents', and allowing the '+' operator to join Dictionary instances with other mappings, including Dictionary instances.</p> <p>In addition, it differs in 2 other significant ways:     1) When returning 'keys', 'values' and 'items', this class returns them         as tuples instead of KeysView, ValuesView, and ItemsView.     2) It includes the same functionality as 'defaultdict' in the python         standard library, including a 'setdefault' method.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, Any]</code> <p>stored dictionary. Defaults to an empty dict.</p> <code>field(default_factory=dict)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.default_factory","title":"<code>default_factory: Any | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Class Methods</p>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.add","title":"<code>add(item, **kwargs)</code>","text":"<p>Adds 'item' to the 'contents' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[Hashable, Any]</code> <p>items to add to 'contents' attribute.</p> required <code>kwargs</code> <code>Any</code> <p>creates a consistent interface even when subclasses have additional parameters.</p> <code>{}</code> Source code in <code>src/camina/mapping.py</code> <pre><code>def add(self, item: Mapping[Hashable, Any], **kwargs: Any) -&gt; None:\n\"\"\"Adds 'item' to the 'contents' attribute.\n    Args:\n        item (Mapping[Hashable, Any]): items to add to 'contents' attribute.\n        kwargs: creates a consistent interface even when subclasses have\n            additional parameters.\n    \"\"\"\nself.contents.update(item, **kwargs)\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.delete","title":"<code>delete(item)</code>","text":"<p>Deletes 'item' in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Hashable</code> <p>key in 'contents' to delete the key/value pair.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def delete(self, item: Hashable) -&gt; None:\n\"\"\"Deletes 'item' in 'contents'.\n    Args:\n        item (Hashable): key in 'contents' to delete the key/value pair.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.fromkeys","title":"<code>fromkeys(keys, value, **kwargs)</code>  <code>classmethod</code>","text":"<p>Emulates the 'fromkeys' class method from a python dict.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Sequence[Hashable]</code> <p>items to be keys in a new Dictionary.</p> required <code>value</code> <code>Any</code> <p>the value to use for all values in a new Dictionary.</p> required <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>Dictionary</code> <p>formed from 'keys' and 'value'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>@classmethod\ndef fromkeys(\ncls,\nkeys: Sequence[Hashable],\nvalue: Any,\n**kwargs: Any) -&gt; Dictionary:\n\"\"\"Emulates the 'fromkeys' class method from a python dict.\n    Args:\n        keys (Sequence[Hashable]): items to be keys in a new Dictionary.\n        value (Any): the value to use for all values in a new Dictionary.\n    Returns:\n        Dictionary: formed from 'keys' and 'value'.\n    \"\"\"\nreturn cls(contents = dict.fromkeys(keys, value), **kwargs)\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.get","title":"<code>get(key, default=None)</code>","text":"<p>Returns value in 'contents' or default options.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key for value in 'contents'.</p> required <code>default</code> <code>Optional[Any]</code> <p>default value to return if 'key' is not found in 'contents'.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if 'key' is not in the Dictionary and 'default' and the 'default_factory' attribute are both None.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>value matching key in 'contents' or 'default_factory' value.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def get(self, key: Hashable, default: Any | None = None) -&gt; Any:\n\"\"\"Returns value in 'contents' or default options.\n    Args:\n        key (Hashable): key for value in 'contents'.\n        default (Optional[Any]): default value to return if 'key' is not\n            found in 'contents'.\n    Raises:\n        KeyError: if 'key' is not in the Dictionary and 'default' and the\n            'default_factory' attribute are both None.\n    Returns:\n        Any: value matching key in 'contents' or 'default_factory' value.\n    \"\"\"\ntry:\nreturn self[key]\nexcept (KeyError, TypeError):\nif default is None:\nif self.default_factory is None:\nraise KeyError(f'{key} is not in the Dictionary')\nelse:\ntry:\nreturn self.default_factory()\nexcept TypeError:\nreturn self.default_factory\nelse:\nreturn default\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.items","title":"<code>items()</code>","text":"<p>Emulates python dict 'items' method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, Any], ...]</code> <p>tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, Any], ...]:\n\"\"\"Emulates python dict 'items' method.\n    Returns:\n        tuple[tuple[Hashable], Any]: a tuple equivalent to dict.items().\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values()))\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.keys","title":"<code>keys()</code>","text":"<p>Returns 'contents' keys as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>tuple[Hashable, ...]: a tuple equivalent to dict.keys().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Returns 'contents' keys as a tuple.\n    Returns:\n        tuple[Hashable, ...]: a tuple equivalent to dict.keys().\n    \"\"\"\nreturn tuple(self.contents.keys())\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.setdefault","title":"<code>setdefault(value)</code>","text":"<p>Sets default value to return when 'get' method is used.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>default value to return when 'get' is called and the 'default' parameter to 'get' is None.</p> required Source code in <code>src/camina/mapping.py</code> <pre><code>def setdefault(self, value: Any) -&gt; None:\n\"\"\"Sets default value to return when 'get' method is used.\n    Args:\n        value (Any): default value to return when 'get' is called and the\n            'default' parameter to 'get' is None.\n    \"\"\"\nself.default_factory = value\nreturn\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of 'contents'.</p> <p>This method applies 'include' before 'exclude' if both are passed. If 'include' is None, all existing items will be added to the new subset class instance before 'exclude' is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to include in the new Dictionary instance.</p> <code>None</code> <code>exclude</code> <code>Optional[Hashable | Sequence[Hashable]]</code> <p>key(s) to exclude from the new Dictionary instance.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'include' and 'exclude' are both None.</p> <p>Returns:</p> Name Type Description <code>Dictionary</code> <code>Dictionary</code> <p>with only keys from 'include' and no keys in 'exclude'.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def subset(\nself,\ninclude: Hashable | Sequence[Hashable] | None = None,\nexclude: Hashable | Sequence[Hashable] | None = None) -&gt; Dictionary:\n\"\"\"Returns a new instance with a subset of 'contents'.\n    This method applies 'include' before 'exclude' if both are passed. If\n    'include' is None, all existing items will be added to the new subset\n    class instance before 'exclude' is applied.\n    Args:\n        include (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            include in the new Dictionary instance.\n        exclude (Optional[Hashable | Sequence[Hashable]]): key(s) to\n            exclude from the new Dictionary instance.\n    Raises:\n        ValueError: if 'include' and 'exclude' are both None.\n    Returns:\n        Dictionary: with only keys from 'include' and no keys in 'exclude'.\n    \"\"\"\nif include is None and exclude is None:\nraise ValueError('include or exclude must not be None')\nelse:\nif include is None:\ncontents = copy.deepcopy(self.contents)\nelse:\ninclude = list(convert.iterify(include))\ncontents = {k: self.contents[k] for k in include}\nif exclude is not None:\nexclude = list(convert.iterify(exclude))\ncontents = {\nk: v for k, v in contents.items()\nif k not in exclude}\nnew_dictionary = copy.deepcopy(self)\nnew_dictionary.contents = contents\nreturn new_dictionary\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Dictionary.values","title":"<code>values()</code>","text":"<p>Returns 'contents' values as a tuple.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: a tuple equivalent to dict.values().</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Returns 'contents' values as a tuple.\n    Returns:\n        tuple[Any, ...]: a tuple equivalent to dict.values().\n    \"\"\"\nreturn tuple(self.contents.values())\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Repository","title":"<code>Repository</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Dictionary</code></p> <p>Dictionary with inferred keys based on items added.</p> <p>A Repository differs from an ordinary python dict in ways inherited from Dictionary. In addition, it differs in 2 other significant ways:     1) The 'add' method relies on the internal '_get_name__' method to         assign a str key for the passed item.     2) It includes an 'overwrite' parameter which allows users to determine         whether existing items will be overwritten when the inferred key         matches an existing one or whether a new key will be inferred by         adding an integer counter as a suffix to the key.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableMapping[Hashable, Any]</code> <p>stored dictionary. Defaults to an empty dict.</p> <code>field(default_factory=dict)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default callable to use to create the default value.</p> <code>None</code> <code>overwrite</code> <code>Optional[bool]</code> <p>whether to overwrite existing items in the stored dictionary with the same inferred keys (True) or automatically infer a new key based upon a counter suffix (False). Defaults to False.</p> <code>False</code>"},{"location":"reference/camina/mapping/#camina.mapping.Repository.overwrite","title":"<code>overwrite: bool | None = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/mapping/#camina.mapping.Repository._get_name","title":"<code>_get_name(item)</code>","text":"<p>Infers key name for 'item'</p> <p>By default, this method uses the 'namify' function in camina. Override this method to use a different naming function.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to infer the name for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>inferred name.</p> Source code in <code>src/camina/mapping.py</code> <pre><code>def _get_name(self, item: Any) -&gt; str:\n\"\"\"Infers key name for 'item'\n    By default, this method uses the 'namify' function in camina. Override\n    this method to use a different naming function.\n    Args:\n        item (Any): item to infer the name for.\n    Returns:\n        str: inferred name.\n    \"\"\"\nreturn label.namify(item)\n</code></pre>"},{"location":"reference/camina/mapping/#camina.mapping.Repository.add","title":"<code>add(item, key=None, **kwargs)</code>","text":"<p>Adds 'item' to the 'contents' attribute.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to add to 'contents' attribute.</p> required <code>key</code> <code>Optional[str]</code> <p>key to use for 'item' if the user does not want the key to be inferred.</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>creates a consistent interface even when subclasses have additional parameters.</p> <code>{}</code> Source code in <code>src/camina/mapping.py</code> <pre><code>def add(self, item: Any, key: str | None = None, **kwargs: Any) -&gt; None:\n\"\"\"Adds 'item' to the 'contents' attribute.\n    Args:\n        item (Any): item to add to 'contents' attribute.\n        key (Optional[str]): key to use for 'item' if the user does not want\n            the key to be inferred.\n        kwargs: creates a consistent interface even when subclasses have\n            additional parameters.\n    \"\"\"\nkey = key or self._get_name(item = item)\nif not self.overwrite:\nkey = modify.uniquify(key = key, dictionary = self)\nself.contents.update({key: item}, **kwargs)\nreturn\n</code></pre>"},{"location":"reference/camina/modify/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> modify","text":"<p>Functions that modify stored data without changing the data type</p> Contents <p>Adders:     add_prefix (dispatcher): adds a str prefix to item.     add_slots: adds 'slots' to a dataclass.     add_suffix (dispatcher): adds a str suffix to item. Dividers:     cleave (dispatcher): divides an item into 2 parts based on         'divider'.     separate (dispatcher): divides an item into n+1 parts based on         'divider'. Subtractors:     deduplicate (dispatcher): removes duplicate data from an item.     drop_dunders: drops strings from a list if they start and end with         double underscores.     drop_prefix (dispatcher): removes a str prefix from an item.     drop_prefix_from_dict     drop_prefix_from_list     drop_prefix_from_set     drop_prefix_from_str     drop_prefix_from_tuple     drop_privates     drop_substring (dispatcher): removes a substring from an item.     drop_suffix (dispatcher): removes a str suffix from an item. Other:     capitalify: converts a snake case str to capital case.     snakify: converts a capital case str to snake case.     uniquify: returns a unique key for a dict.</p> <p>To Do:</p>"},{"location":"reference/camina/modify/#camina.modify.add_prefix","title":"<code>add_prefix(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>Optional[str]</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef add_prefix(\nitem: Any, /,\nprefix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Any:\n\"\"\"Adds 'prefix' to 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (Optional[str]): str to add between 'item' and 'prefix'.\n            Defaults to '', which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified item.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_prefix_to_dict","title":"<code>add_prefix_to_dict(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(Mapping)\ndef add_prefix_to_dict(\nitem: Mapping[str, Any], /,\nprefix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Mapping[str, Any]:\n\"\"\"Adds 'prefix' to keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\nbase = type(item)\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\ntool = add_prefix if recursive else add_prefix_to_str\nreturn base({tool(k, **kwargs): v for k, v in item.items()})\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_prefix_to_list","title":"<code>add_prefix_to_list(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>MutableSequence[str]</code> <p>modified mutable sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(MutableSequence)\ndef add_prefix_to_list(\nitem: MutableSequence[str], /,\nprefix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; MutableSequence[str]:\n\"\"\"Adds 'prefix' to items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified mutable sequence.\n    \"\"\"\nbase = type(item)\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\ntool = add_prefix if recursive else add_prefix_to_str\nreturn base([tool(i, **kwargs) for i in item])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_prefix_to_set","title":"<code>add_prefix_to_set(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(AbstractSet)\ndef add_prefix_to_set(\nitem: AbstractSet[str], /,\nprefix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; AbstractSet[str]:\n\"\"\"Adds 'prefix' to items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\nbase = type(item)\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\ntool = add_prefix if recursive else add_prefix_to_str\nreturn base({tool(i, **kwargs) for i in item})\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_prefix_to_str","title":"<code>add_prefix_to_str(item, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False. This argument has no effect if 'item' is a str type.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(str)\ndef add_prefix_to_str(\nitem: str,\nprefix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; str:\n\"\"\"Adds 'prefix' to 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False. This argument has no effect\n            if 'item' is a str type.\n    Returns:\n        str: modified str.\n    \"\"\"\nreturn divider.join([prefix, item])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_prefix_to_tuple","title":"<code>add_prefix_to_tuple(item, /, prefix, divider='', recursive=False)</code>","text":"<p>Adds 'prefix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_prefix.register(tuple)\ndef add_prefix_to_tuple(\nitem: tuple[str, ...], /,\nprefix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; tuple[str, ...]:\n\"\"\"Adds 'prefix' to items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nkwargs = {'prefix': prefix, 'divider': divider, 'recursive': recursive}\nreturn tuple(add_prefix_to_list(item, **kwargs))\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_slots","title":"<code>add_slots(item)</code>","text":"<p>Adds slots to dataclass with default values.</p> <p>Derived from code here: https://gitquirks.com/ericvsmith/dataclasses/blob/master/dataclass_tools.py</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Type[Any]</code> <p>dataclass to add slots to.</p> required <p>Returns:</p> Type Description <code>type[Any]</code> <p>Type[Any]: class with 'slots' added.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'slots' is already in item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def add_slots(item: type[Any]) -&gt; type[Any]:\n\"\"\"Adds slots to dataclass with default values.\n    Derived from code here:\n    https://gitquirks.com/ericvsmith/dataclasses/blob/master/dataclass_tools.py\n    Args:\n        item (Type[Any]): dataclass to add slots to.\n    Returns:\n        Type[Any]: class with '__slots__' added.\n    Raises:\n        TypeError: if '__slots__' is already in item.\n    \"\"\"\nif '__slots__' in item.__dict__:\nraise TypeError(f'{item.__name__} already contains __slots__')\nelse:\nitem_dict = dict(item.__dict__)\nfield_names = tuple(f.name for f in dataclasses.fields(item))\nitem_dict['__slots__'] = field_names\nfor field_name in field_names:\nitem_dict.pop(field_name, None)\nitem_dict.pop('__dict__', None)\nqualname = getattr(item, '__qualname__', None)\nitem = type(item)(item.__name__, item.__bases__, item_dict)\nif qualname is not None:\nitem.__qualname__ = qualname\nreturn item\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_suffix","title":"<code>add_suffix(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>Optional[str]</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef add_suffix(\nitem: Any, /,\nsuffix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Any:\n\"\"\"Adds 'suffix' to 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (Optional[str]): str to add between 'item' and 'suffix'.\n            Defaults to '', which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified item.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_suffix_to_dict","title":"<code>add_suffix_to_dict(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(Mapping)\ndef add_suffix_to_dict(\nitem: Mapping[str, Any], /,\nsuffix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; Mapping[str, Any]:\n\"\"\"Adds 'suffix' to keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\nbase = type(item)\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\ntool = add_suffix if recursive else add_suffix_to_str\nreturn base({tool(k, **kwargs): v for k, v in item.items()})\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_suffix_to_list","title":"<code>add_suffix_to_list(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>MutableSequence[str]</code> <p>modified mutable sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(MutableSequence)\ndef add_suffix_to_list(\nitem: MutableSequence[str], /,\nsuffix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; MutableSequence[str]:\n\"\"\"Adds 'suffix' to items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Any: modified mutable sequence.\n    \"\"\"\nbase = type(item)\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\ntool = add_suffix if recursive else add_suffix_to_str\nreturn base([tool(i, **kwargs) for i in item])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_suffix_to_set","title":"<code>add_suffix_to_set(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(AbstractSet)\ndef add_suffix_to_set(\nitem: AbstractSet[str], /,\nsuffix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; AbstractSet[str]:\n\"\"\"Adds 'suffix' to items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\nbase = type(item)\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\ntool = add_suffix if recursive else add_suffix_to_str\nreturn base({tool(i, **kwargs) for i in item})\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_suffix_to_str","title":"<code>add_suffix_to_str(item, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False. This argument has no effect if 'item' is a str type.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(str)\ndef add_suffix_to_str(\nitem: str,\nsuffix: str,\ndivider: str | None = '',\nrecursive: bool | None = False) -&gt; str:\n\"\"\"Adds 'suffix' to 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False. This argument has no effect\n            if 'item' is a str type.\n    Returns:\n        str: modified str.\n    \"\"\"\nreturn divider.join([item, suffix])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.add_suffix_to_tuple","title":"<code>add_suffix_to_tuple(item, /, suffix, divider='', recursive=False)</code>","text":"<p>Adds 'suffix' to items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'suffix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <code>recursive</code> <code>Optional[bool]</code> <p>False): if 'item' is nested, whether to apply the function to all nested objects as well (True) or merely the top level object (False). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@add_suffix.register(tuple)\ndef add_suffix_to_tuple(\nitem: tuple[str, ...], /,\nsuffix: str,\ndivider: str = '',\nrecursive: bool | None = False) -&gt; tuple[str, ...]:\n\"\"\"Adds 'suffix' to items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n        divider (str): str to add between 'item' and 'suffix'. Defaults to '',\n            which means no divider will be added.\n        recursive (Optional[bool]: False): if 'item' is nested, whether to apply\n            the function to all nested objects as well (True) or merely the top\n            level object (False). Defaults to False.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    \"\"\"\nkwargs = {'suffix': suffix, 'divider': divider, 'recursive': recursive}\nreturn tuple(add_suffix_to_list(item, **kwargs))\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.capitalify","title":"<code>capitalify(item)</code>","text":"<p>Converts a snake case str to capital case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'item' converted to capital case.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def capitalify(item: str) -&gt; str:\n\"\"\"Converts a snake case str to capital case.\n    Args:\n        item (str): str to convert.\n    Returns:\n        str: 'item' converted to capital case.\n    \"\"\"\nreturn item.replace('_', ' ').title().replace(' ', '')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.cleave","title":"<code>cleave(item, /, divider, return_last=True, raise_error=False)</code>","text":"<p>Divides 'item' into 2 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide 'item' upon.</p> required <code>return_last</code> <code>bool</code> <p>whether to split 'item' upon the first (False) or last appearance of 'divider'.</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Type Description <code>tuple[Any, Any]</code> <p>tuple[Any, Any]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef cleave(\nitem: Any, /,\ndivider: Any,\nreturn_last: bool = True,\nraise_error: bool = False) -&gt; tuple[Any, Any]:\n\"\"\"Divides 'item' into 2 parts based on 'divider'.\n    Args:\n        item (Any): item to be divided.\n        divider (Any): item to divide 'item' upon.\n        return_last (bool): whether to split 'item' upon the first (False) or\n            last appearance of 'divider'.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        tuple[Any, Any]: parts of 'item' on either side of 'divider' unless\n            'divider' is not in 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.cleave_str","title":"<code>cleave_str(item, /, divider='_', return_last=True, raise_error=False)</code>","text":"<p>Divides 'item' into 2 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be divided.</p> required <code>divider</code> <code>str</code> <p>item to divide 'item' upon.</p> <code>'_'</code> <code>return_last</code> <code>bool</code> <p>whether to split 'item' upon the first (False) or last appearance of 'divider'.</p> <code>True</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'divider' is not in 'item' and 'raise_error' is True.</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>tuple[str, str]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@cleave.register\ndef cleave_str(\nitem: str, /,\ndivider: str = '_',\nreturn_last: bool = True,\nraise_error: bool = False) -&gt; tuple[str, str]:\n\"\"\"Divides 'item' into 2 parts based on 'divider'.\n    Args:\n        item (str): item to be divided.\n        divider (str): item to divide 'item' upon.\n        return_last (bool): whether to split 'item' upon the first (False) or\n            last appearance of 'divider'.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        ValueError: if 'divider' is not in 'item' and 'raise_error' is True.\n    Returns:\n        tuple[str, str]: parts of 'item' on either side of 'divider' unless\n            'divider' is not in 'item'.\n    \"\"\"\nif divider in item:\nif return_last:\nsuffix = item.split(divider)[-1]\nelse:\nsuffix = item.split(divider)[0]\nprefix = item[:-len(suffix) - 1]\nelif raise_error:\nraise ValueError(f'{divider} is not in {item}')\nelse:\nprefix = suffix = item\nreturn prefix, suffix\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.deduplicate","title":"<code>deduplicate(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to deduplicate.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>deduplicated item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef deduplicate(item: Any, /) -&gt; Any:\n\"\"\"Deduplicates contents of 'item.\n    Args:\n        item (Any): item to deduplicate.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: deduplicated item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.deduplicate_list","title":"<code>deduplicate_list(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[Any]</code> <p>item to deduplicate.</p> required <p>Returns:</p> Type Description <code>MutableSequence[Any]</code> <p>MutableSequence[Any]: deduplicated item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@deduplicate.register(MutableSequence)\ndef deduplicate_list(item: MutableSequence[Any], /) -&gt; MutableSequence[Any]:\n\"\"\"Deduplicates contents of 'item.\n    Args:\n        item (MutableSequence[Any]): item to deduplicate.\n    Returns:\n        MutableSequence[Any]: deduplicated item.\n    \"\"\"\nbase = type(item)\ncontents = list(dict.fromkeys(item))\nreturn base(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.deduplicate_tuple","title":"<code>deduplicate_tuple(item)</code>","text":"<p>Deduplicates contents of 'item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[Any, ...]</code> <p>item to deduplicate.</p> required <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: deduplicated item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@deduplicate.register(tuple)\ndef deduplicate_tuple(item: tuple[Any, ...], /) -&gt; tuple[Any, ...]:\n\"\"\"Deduplicates contents of 'item.\n    Args:\n        item (tuple[Any, ...]): item to deduplicate.\n    Returns:\n        tuple[Any, ...]: deduplicated item.\n    \"\"\"\nreturn tuple(deduplicate_list(item))\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_dunders","title":"<code>drop_dunders(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to modify.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>item with entries dropped beginning with a double underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not a registered type.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_dunders(item: Any, /) -&gt; Any:\n\"\"\"Drops items in 'item' beginning with a double underscore.\n    Args:\n        item (Any): item to modify.\n    Returns:\n        Any: item with entries dropped beginning with a double underscore.\n    Raises:\n        TypeError: if 'item' is not a registered type.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_dunders_dict","title":"<code>drop_dunders_dict(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>dict-like object with str keys that might have double underscores at the beginning of the key names.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: dict-luke object with entries dropped if the key name begin with a double underscore.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_dunders.register(Mapping)\ndef drop_dunders_dict(item: Mapping[str, Any], /) -&gt; Mapping[str, Any]:\n\"\"\"Drops items in 'item' beginning with a double underscore.\n    Args:\n        item (Mapping[str, Any]): dict-like object with str keys that might have\n            double underscores at the beginning of the key names.\n    Returns:\n        Mapping[str, Any]: dict-luke object with entries dropped if the key name\n            begin with a double underscore.\n    \"\"\"\nbase = type(item)\nreturn base({k: v for k, v in item.items() if not k.startswith('__')})\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_dunders_list","title":"<code>drop_dunders_list(item)</code>","text":"<p>Drops items in 'item' beginning with a double underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str | object]</code> <p>list-like object with str items or names that might have double underscores at their beginnings.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str | object]</code> <p>MutableSequence[str | object]: list-like object with items dropped if they or their names begin with a double underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not contain str types or objects with either 'name' or 'name' attributes.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_dunders.register(MutableSequence)\ndef drop_dunders_list(\nitem: MutableSequence[str | object], /) -&gt; MutableSequence[str | object]:\n\"\"\"Drops items in 'item' beginning with a double underscore.\n    Args:\n        item (MutableSequence[str | object]): list-like object with str items or\n            names that might have double underscores at their beginnings.\n    Returns:\n        MutableSequence[str | object]: list-like object with items dropped if\n            they or their names begin with a double underscore.\n    Raises:\n        TypeError: if 'item' does not contain str types or objects with either\n            'name' or '__name__' attributes.\n    \"\"\"\nbase = type(item)\nif len(item) &gt; 0 and all(isinstance(i, str) for i in item):\nreturn base([i for i in item if not i.startswith('__')])\nelif len(item) &gt; 0 and all(hasattr(i, 'name') for i in item):\nreturn base([i for i in item if not i.name.startswith('__')])\nelif len(item) &gt; 0 and all(hasattr(i, '__name__') for i in item):\nreturn base([i for i in item if not i.__name__.startswith('__')])\nelif len == 0:\nreturn item\nelse:\nraise TypeError(\n'items in item must be str types or have name or __name__ '\n'attributes')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_prefix","title":"<code>drop_prefix(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_prefix(item: Any, /, prefix: str, divider: str = '') -&gt; Any:\n\"\"\"Drops 'prefix' from 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: modified item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_prefix_from_dict","title":"<code>drop_prefix_from_dict(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(Mapping)\ndef drop_prefix_from_dict(\nitem: Mapping[str, Any], /,\nprefix: str,\ndivider: str = '') -&gt; Mapping[str, Any]:\n\"\"\"Drops 'prefix' from keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\ncontents = {\ndrop_prefix(item = k, prefix = prefix, divider = divider): v\nfor k, v in item.items()}\nif isinstance(item, dict):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_prefix_from_list","title":"<code>drop_prefix_from_list(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(MutableSequence)\ndef drop_prefix_from_list(\nitem: MutableSequence[str], /,\nprefix: str,\ndivider: str = '') -&gt; MutableSequence[str]:\n\"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        MutableSequence[str]: modified sequence.\n    \"\"\"\ncontents = [\ndrop_prefix(item = i, prefix = prefix, divider = divider) for i in item]\nif isinstance(item, list):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_prefix_from_set","title":"<code>drop_prefix_from_set(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(AbstractSet)\ndef drop_prefix_from_set(\nitem: AbstractSet[str], /,\nprefix: str,\ndivider: str = '') -&gt; AbstractSet[str]:\n\"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\ncontents = {\ndrop_prefix(item = i, prefix = prefix, divider = divider) for i in item}\nif isinstance(item, set):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_prefix_from_str","title":"<code>drop_prefix_from_str(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register\ndef drop_prefix_from_str(item: str, /, prefix: str, divider: str = '') -&gt; str:\n\"\"\"Drops 'prefix' from 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        str: modified str.\n    \"\"\"\nprefix = ''.join([prefix, divider])\nif item.startswith(prefix):\nreturn item[len(prefix):]\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_prefix_from_tuple","title":"<code>drop_prefix_from_tuple(item, /, prefix, divider='')</code>","text":"<p>Drops 'prefix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>prefix</code> <code>str</code> <p>prefix to be added to 'item'.</p> required <code>divider</code> <code>str</code> <p>str to add between 'item' and 'prefix'. Defaults to '', which means no divider will be added.</p> <code>''</code> <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_prefix.register(tuple)\ndef drop_prefix_from_tuple(\nitem: tuple[str, ...], /,\nprefix: str,\ndivider: str = '') -&gt; tuple[str, ...]:\n\"\"\"Drops 'prefix' from items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        prefix (str): prefix to be added to 'item'.\n        divider (str): str to add between 'item' and 'prefix'. Defaults to '',\n            which means no divider will be added.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    \"\"\"\nreturn tuple(\n[drop_prefix(item = i, prefix = prefix, divider = divider)\nfor i in item])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_privates","title":"<code>drop_privates(item)</code>","text":"<p>Drops items in 'item' with names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to modify.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>item with entries dropped beginning with an underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' is not a registered type.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_privates(item: Any, /) -&gt; Any:\n\"\"\"Drops items in 'item' with names beginning with an underscore.\n    Args:\n        item (Any): item to modify.\n    Returns:\n        Any: item with entries dropped beginning with an underscore.\n    Raises:\n        TypeError: if 'item' is not a registered type.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_privates_dict","title":"<code>drop_privates_dict(item)</code>","text":"<p>Drops items in 'item' with key names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>dict-like object with str keys that might have underscores at the beginning of the key names.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: dict-luke object with entries dropped if the key name begin with an underscore.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_privates.register(Mapping)\ndef drop_privates_dict(item: Mapping[str, Any], /) -&gt; Mapping[str, Any]:\n\"\"\"Drops items in 'item' with key names beginning with an underscore.\n    Args:\n        item (Mapping[str, Any]): dict-like object with str keys that might have\n            underscores at the beginning of the key names.\n    Returns:\n        Mapping[str, Any]: dict-luke object with entries dropped if the key name\n            begin with an underscore.\n    \"\"\"\nbase = type(item)\nreturn base({k: v for k, v in item.items() if not k.startswith('_')})\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_privates_list","title":"<code>drop_privates_list(item)</code>","text":"<p>Drops items in 'item' with names beginning with an underscore.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str | object]</code> <p>list-like object with str items or names that might have underscores at their beginnings.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str | object]</code> <p>MutableSequence[str | object]: list-like object with items dropped if they or their names begin with an underscore.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if 'item' does not contain str types or objects with either 'name' or 'name' attributes.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_privates.register(MutableSequence)\ndef drop_privates_list(\nitem: MutableSequence[str | object], /) -&gt; MutableSequence[str | object]:\n\"\"\"Drops items in 'item' with names beginning with an underscore.\n    Args:\n        item (MutableSequence[str | object]): list-like object with str items or\n            names that might have underscores at their beginnings.\n    Returns:\n        MutableSequence[str | object]: list-like object with items dropped if\n            they or their names begin with an underscore.\n    Raises:\n        TypeError: if 'item' does not contain str types or objects with either\n            'name' or '__name__' attributes.\n    \"\"\"\nbase = type(item)\nif len(item) &gt; 0 and all(isinstance(i, str) for i in item):\nreturn base([i for i in item if not i.startswith('_')])\nelif len(item) &gt; 0 and all(hasattr(i, 'name') for i in item):\nreturn base([i for i in item if not i.name.startswith('_')])\nelif len(item) &gt; 0 and all(hasattr(i, '__name__') for i in item):\nreturn base([i for i in item if not i.__name__.startswith('_')])\nelif len == 0:\nreturn item\nelse:\nraise TypeError(\n'items in item must be str types or have name or __name__ '\n'attributes')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_substring","title":"<code>drop_substring(item, /, substring)</code>","text":"<p>Drops 'substring' from 'item' with a possible 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_substring(item: Any, /, substring: str) -&gt; Any:\n\"\"\"Drops 'substring' from 'item' with a possible 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: modified item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_substring_from_dict","title":"<code>drop_substring_from_dict(item, /, substring)</code>","text":"<p>Drops 'substring' from keys in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(Mapping)\ndef drop_substring_from_dict(\nitem: Mapping[str, Any], /,\nsubstring: str) -&gt; Mapping[str, Any]:\n\"\"\"Drops 'substring' from keys in 'item'.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\ncontents = {\ndrop_substring(item = k, substring = substring): v\nfor k, v in item.items()}\nif isinstance(item, dict):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_substring_from_list","title":"<code>drop_substring_from_list(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(MutableSequence)\ndef drop_substring_from_list(\nitem: MutableSequence[str], /,\nsubstring: str) -&gt; MutableSequence[str]:\n\"\"\"Drops 'substring' from items in 'item'.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        MutableSequence[str]: modified sequence.\n    \"\"\"\ncontents = [drop_substring(item = i, substring = substring) for i in item]\nif isinstance(item, list):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_substring_from_set","title":"<code>drop_substring_from_set(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(AbstractSet)\ndef drop_substring_from_set(item: AbstractSet[str], /, substring: str) -&gt; AbstractSet[str]:\n\"\"\"Drops 'substring' from items in 'item'.\n    Args:\n        item (Set[str]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\ncontents = {drop_substring(item = i, substring = substring) for i in item}\nif isinstance(item, set):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_substring_from_str","title":"<code>drop_substring_from_str(item, /, substring)</code>","text":"<p>Drops 'substring' from 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register\ndef drop_substring_from_str(item: str, /, substring: str) -&gt; str:\n\"\"\"Drops 'substring' from 'item'.\n    Args:\n        item (str): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        str: modified str.\n    \"\"\"\nif substring in item:\nreturn item.replace(substring, '')\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_substring_from_tuple","title":"<code>drop_substring_from_tuple(item, /, substring)</code>","text":"<p>Drops 'substring' from items in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>substring</code> <code>str</code> <p>substring to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_substring.register(tuple)\ndef drop_substring_from_tuple(\nitem: tuple[str, ...], /,\nsubstring: str) -&gt; tuple[str, ...]:\n\"\"\"Drops 'substring' from items in 'item'.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        substring (str): substring to be added to 'item'.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    \"\"\"\nreturn tuple(\n[drop_substring(item = i, substring = substring) for i in item])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_suffix","title":"<code>drop_suffix(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>modified item.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef drop_suffix(item: Any, /, suffix: str, divider: str = '') -&gt; Any:\n\"\"\"Drops 'suffix' from 'item' with 'divider' in between.\n    Args:\n        item (Any): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        Any: modified item.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_suffix_from_dict","title":"<code>drop_suffix_from_dict(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from keys in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Mapping[str, Any]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Mapping[str, Any]</code> <p>Mapping[str, Any]: modified mapping.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(Mapping)\ndef drop_suffix_from_dict(\nitem: Mapping[str, Any], /,\nsuffix: str,\ndivider: str = '') -&gt; Mapping[str, Any]:\n\"\"\"Drops 'suffix' from keys in 'item' with 'divider' in between.\n    Args:\n        item (Mapping[str, Any]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        Mapping[str, Any]: modified mapping.\n    \"\"\"\ncontents = {\ndrop_suffix(item = k, suffix = suffix, divider = divider): v\nfor k, v in item.items()}\nif isinstance(item, dict):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_suffix_from_list","title":"<code>drop_suffix_from_list(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>MutableSequence[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>MutableSequence[str]</code> <p>MutableSequence[str]: modified sequence.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(MutableSequence)\ndef drop_suffix_from_list(\nitem: MutableSequence[str], /,\nsuffix: str,\ndivider: str = '') -&gt; MutableSequence[str]:\n\"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n    Args:\n        item (MutableSequence[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        MutableSequence[str]: modified sequence.\n    \"\"\"\ncontents = [\ndrop_suffix(item = i, suffix = suffix, divider = divider) for i in item]\nif isinstance(item, list):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_suffix_from_set","title":"<code>drop_suffix_from_set(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Set[str]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: modified set.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(AbstractSet)\ndef drop_suffix_from_set(\nitem: AbstractSet[str], /,\nsuffix: str,\ndivider: str = '') -&gt; AbstractSet[str]:\n\"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n    Args:\n        item (Set[str]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        Set[str]: modified set.\n    \"\"\"\ncontents = {\ndrop_suffix(item = i, suffix = suffix, divider = divider) for i in item}\nif isinstance(item, set):\nreturn contents\nelse:\nvessel = item.__class__\nreturn vessel(contents)\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_suffix_from_str","title":"<code>drop_suffix_from_str(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>modified str.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register\ndef drop_suffix_from_str(item: str, /, suffix: str, divider: str = '') -&gt; str:\n\"\"\"Drops 'suffix' from 'item' with 'divider' in between.\n    Args:\n        item (str): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        str: modified str.\n    \"\"\"\nsuffix = ''.join([suffix, divider])\nif item.endswith(suffix):\nreturn item.removesuffix(suffix)\nelse:\nreturn item\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.drop_suffix_from_tuple","title":"<code>drop_suffix_from_tuple(item, /, suffix, divider='')</code>","text":"<p>Drops 'suffix' from items in 'item' with 'divider' in between.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>tuple[str, ...]</code> <p>item to be modified.</p> required <code>suffix</code> <code>str</code> <p>suffix to be added to 'item'.</p> required <p>Returns:</p> Type Description <code>tuple[str, ...]</code> <p>tuple[str, ...]: modified tuple.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@drop_suffix.register(tuple)\ndef drop_suffix_from_tuple(\nitem: tuple[str, ...], /,\nsuffix: str,\ndivider: str = '') -&gt; tuple[str, ...]:\n\"\"\"Drops 'suffix' from items in 'item' with 'divider' in between.\n    Args:\n        item (tuple[str, ...]): item to be modified.\n        suffix (str): suffix to be added to 'item'.\n    Returns:\n        tuple[str, ...]: modified tuple.\n    \"\"\"\nreturn tuple(\n[drop_suffix(item = i, suffix = suffix, divider = divider)\nfor i in item])\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.separate","title":"<code>separate(item, /, divider, raise_error=False)</code>","text":"<p>Divides 'item' into n+1 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>item to be divided.</p> required <code>divider</code> <code>Any</code> <p>item to divide 'item' upon.</p> required <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>if no registered function supports the type of 'item'.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>list[Any, ...]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@functools.singledispatch\ndef separate(\nitem: Any, /,\ndivider: Any,\nraise_error: bool = False) -&gt; tuple[Any, ...]:\n\"\"\"Divides 'item' into n+1 parts based on 'divider'.\n    Args:\n        item (Any): item to be divided.\n        divider (Any): item to divide 'item' upon.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        TypeError: if no registered function supports the type of 'item'.\n    Returns:\n        list[Any, ...]: parts of 'item' on either side of 'divider' unless\n            'divider' is not in 'item'.\n    \"\"\"\nraise TypeError(f'item is not a supported type for {__name__}')\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.separate_str","title":"<code>separate_str(item, /, divider='_', raise_error=False)</code>","text":"<p>Divides 'item' into n+1 parts based on 'divider'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>item to be divided.</p> required <code>divider</code> <code>str</code> <p>item to divide 'item' upon.</p> <code>'_'</code> <code>raise_error</code> <code>bool</code> <p>whether to raise an error if 'divider' is not in 'item' or to return a tuple containing 'item' twice.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'divider' is not in 'item' and 'raise_error' is True.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: parts of 'item' on either side of 'divider' unless 'divider' is not in 'item'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>@separate.register\ndef separate_str(\nitem: str, /,\ndivider: str = '_',\nraise_error: bool = False) -&gt; list[str]:\n\"\"\"Divides 'item' into n+1 parts based on 'divider'.\n    Args:\n        item (str): item to be divided.\n        divider (str): item to divide 'item' upon.\n        raise_error (bool): whether to raise an error if 'divider' is not in\n            'item' or to return a tuple containing 'item' twice.\n    Raises:\n        ValueError: if 'divider' is not in 'item' and 'raise_error' is True.\n    Returns:\n        list[str]: parts of 'item' on either side of 'divider' unless 'divider'\n            is not in 'item'.\n    \"\"\"\nif divider in item:\nreturn item.split(divider)\nelif raise_error:\nraise ValueError(f'{divider} is not in {item}')\nelse:\nreturn [item]\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.snakify","title":"<code>snakify(item)</code>","text":"<p>Converts a capitalized str to snake case.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>str to convert.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>'item' converted to snake case.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def snakify(item: str) -&gt; str:\n\"\"\"Converts a capitalized str to snake case.\n    Args:\n        item (str): str to convert.\n    Returns:\n        str: 'item' converted to snake case.\n    \"\"\"\nitem = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', item)\nreturn re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', item).lower()\n</code></pre>"},{"location":"reference/camina/modify/#camina.modify.uniquify","title":"<code>uniquify(key, dictionary, index=1)</code>","text":"<p>Creates a unique key name to avoid overwriting an item in 'dictionary'.</p> <p>The function is 1-indexed so that the first attempt to avoid a duplicate will be: \"old_name2\".</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>name of key to test.</p> required <code>dictionary</code> <code>Mapping[Hashable, Any]</code> <p>dict for which a unique key name is sought.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>unique key name for 'dictionary'.</p> Source code in <code>src/camina/modify.py</code> <pre><code>def uniquify(\nkey: str,\ndictionary: Mapping[Hashable, Any],\nindex: int | None = 1) -&gt; str:\n\"\"\"Creates a unique key name to avoid overwriting an item in 'dictionary'.\n    The function is 1-indexed so that the first attempt to avoid a duplicate\n    will be: \"old_name2\".\n    Args:\n        key (str): name of key to test.\n        dictionary (Mapping[Hashable, Any]): dict for which a unique key name\n            is sought.\n    Returns:\n        str: unique key name for 'dictionary'.\n    \"\"\"\nif key not in dictionary:\nreturn key\nelse:\ncounter = index\nwhile True:\ncounter += 1\nif counter &gt; 2:\nname = name.removesuffix(str(counter - 1))\nname = ''.join([key, str(counter)])\nif name not in dictionary:\nreturn name\n</code></pre>"},{"location":"reference/camina/sequence/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> sequence","text":"<p>List-like classes</p> Contents <p>Listing (base.Bunch, MutableSequence): drop-in replacement for a python     list with additional functionality. Hybrid (Listing): iterable with both dict and list interfaces. Stored items     must be hashable or have a 'name' attribute.</p> <p>To Do:</p>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid","title":"<code>Hybrid</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Listing</code></p> <p>Iterable that has both a dict and list interfaces.</p> <p>Hybrid combines the functionality and interfaces of python dicts and lists. It allows duplicate keys and list-like iteration while supporting the easier access methods of dictionaries. In order to support this hybrid approach to iterables, Hybrid can only store items that are hashable or have a 'name' attribute or property that contains or returns a hashable value.</p> <p>A Hybrid inherits the differences between a Listing and an ordinary python list.</p> A Hybrid differs from a Listing in 3 significant ways <p>1) It only stores hashable items or objects for which a str name can be     derived (using the namify function). 2) Hybrid has an interface of both a dict and a list, but stores a list.     Hybrid does this by taking advantage of the 'name' attribute or     hashability of stored items. A 'name' or hash acts as a key to     create the facade of a dict with the items in the stored list     serving as values. This allows for duplicate keys for storing items,     simpler iteration than a dict, and support for returning multiple     matching items. This design comes at the expense of lookup speed. As     a result, Hybrid should only be used if a high volume of access     calls is not anticipated. Ordinarily, the loss of lookup speed     should have negligible effect on overall performance. 3) Hybrids should not store int types. This ensures that when, for     example, a 'hybrid[3]' is called, the item at that index is     returned. If int types are stored, that call would create     uncertainty as to whether an index or item should be returned. By     design, int types are assumed to be calls to return the item at that     index. 4) When using dict access methods, a list of matches may be returned     because a Hybrid allows duplicate pseudo-keys to be used.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Hashable]</code> <p>items to store that are hashable or have a 'name' attribute. Defaults to an empty list.</p> <code>field(default_factory=list)</code> <code>default_factory</code> <code>Optional[Any]</code> <p>default value to return or default function to call when the 'get' method is used. Defaults to None.</p> <code>None</code>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.default_factory","title":"<code>default_factory: Any | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.delete","title":"<code>delete(item)</code>","text":"<p>Deletes item in 'contents'.</p> <p>If 'item' is not an int type, this method looks for a matching 'name' attribute in the stored instances and deletes all such items. If 'key' is an int type, only the item at that index is deleted.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>(Any, int)</code> <p>name or index in 'contents' to delete.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def delete(self, item: Any | int) -&gt; None:\n\"\"\"Deletes item in 'contents'.\n    If 'item' is not an int type, this method looks for a matching 'name'\n    attribute in the stored instances and deletes all such items. If 'key'\n    is an int type, only the item at that index is deleted.\n    Args:\n        key (Any, int): name or index in 'contents' to delete.\n    \"\"\"\nif isinstance(item, int):\ndel self.contents[item]\nelse:\nself.contents = [\nc for c in self.contents if label.namify(c) != item]\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.get","title":"<code>get(key, default=None)</code>","text":"<p>Returns value in 'contents' or default options.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Hashable</code> <p>key for value in 'contents'.</p> required <code>default</code> <code>Optional[Any]</code> <p>default value to return if 'key' is not found in 'contents'.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>if 'key' is not in the Hybrid and 'default' and the 'default_factory' attribute are both None.</p> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>value matching key in 'contents' or 'default_factory' value.</p> Source code in <code>src/camina/sequence.py</code> <pre><code>def get(self, key: Hashable, default: Any | None = None) -&gt; Any:\n\"\"\"Returns value in 'contents' or default options.\n    Args:\n        key (Hashable): key for value in 'contents'.\n        default (Optional[Any]): default value to return if 'key' is not\n            found in 'contents'.\n    Raises:\n        KeyError: if 'key' is not in the Hybrid and 'default' and the\n            'default_factory' attribute are both None.\n    Returns:\n        Any: value matching key in 'contents' or 'default_factory' value.\n    \"\"\"\ntry:\nreturn self[key]\nexcept (KeyError, TypeError):\nif default is None:\nif self.default_factory is None:\nraise KeyError(f'{key} is not in the Hybrid')\nelse:\ntry:\nreturn self.default_factory()\nexcept TypeError:\nreturn self.default_factory\nelse:\nreturn default\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.items","title":"<code>items()</code>","text":"<p>Emulates python dict 'items' method.</p> <p>Returns:</p> Type Description <code>tuple[tuple[Hashable, ...], tuple[Any, ...]]</code> <p>tuple[tuple[Hashable, ...], tuple[Any, ...]]: a tuple equivalent to dict.items(). A Hybrid cannot actually create an ItemsView because that would eliminate any duplicate keys, which are permitted by Hybrid.</p> Source code in <code>src/camina/sequence.py</code> <pre><code>def items(self) -&gt; tuple[tuple[Hashable, ...], tuple[Any, ...]]:\n\"\"\"Emulates python dict 'items' method.\n    Returns:\n        tuple[tuple[Hashable, ...], tuple[Any, ...]]: a tuple equivalent to\n            dict.items(). A Hybrid cannot actually create an ItemsView\n            because that would eliminate any duplicate keys, which are\n            permitted by Hybrid.\n    \"\"\"\nreturn tuple(zip(self.keys(), self.values()))\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.keys","title":"<code>keys()</code>","text":"<p>Emulates python dict 'keys' method.</p> <p>Returns:</p> Type Description <code>tuple[Hashable, ...]</code> <p>tuple[Hashable, ...]: a tuple equivalent to dict.keys(). A Hybrid cannot actually create an KeysView because that would eliminate any duplicate keys, which are permitted by Hybrid.</p> Source code in <code>src/camina/sequence.py</code> <pre><code>def keys(self) -&gt; tuple[Hashable, ...]:\n\"\"\"Emulates python dict 'keys' method.\n    Returns:\n        tuple[Hashable, ...]: a tuple equivalent to dict.keys(). A Hybrid\n            cannot actually create an KeysView because that would eliminate\n            any duplicate keys, which are permitted by Hybrid.\n    \"\"\"\nreturn tuple(label.namify(c) for c in self.contents)\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.setdefault","title":"<code>setdefault(value)</code>","text":"<p>Sets default value to return when 'get' method is used.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>default value to return.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def setdefault(self, value: Any) -&gt; None:\n\"\"\"Sets default value to return when 'get' method is used.\n    Args:\n        value (Any): default value to return.\n    \"\"\"\nself.default_factory = value\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.update","title":"<code>update(items)</code>","text":"<p>Mimics the dict 'update' method by extending 'contents' with 'items'.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Mapping[Any, Any]</code> <p>items to add to the 'contents' attribute. The values of 'items' are added to 'contents' and the keys become the 'name' attributes of those values. As a result, the keys of 'items' are discarded. To mimic dict' update', the passed 'items' values are added to 'contents' by the 'extend' method which adds the values to the end of 'contents'.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def update(self, items: Mapping[Any, Any]) -&gt; None:\n\"\"\"Mimics the dict 'update' method by extending 'contents' with 'items'.\n    Args:\n        items (Mapping[Any, Any]): items to add to the 'contents' attribute.\n            The values of 'items' are added to 'contents' and the keys\n            become the 'name' attributes of those values. As a result, the\n            keys of 'items' are discarded. To mimic dict' update', the\n            passed 'items' values are added to 'contents' by the 'extend'\n            method which adds the values to the end of 'contents'.\n    \"\"\"\nself.extend(list(items.values()))\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Hybrid.values","title":"<code>values()</code>","text":"<p>Emulates python dict 'values' method.</p> <p>Returns:</p> Type Description <code>tuple[Any, ...]</code> <p>tuple[Any, ...]: a tuple equivalent to dict.values(). A Hybrid cannot actually create an ValuesView because that would eliminate any duplicate keys, which are permitted by Hybrid.</p> Source code in <code>src/camina/sequence.py</code> <pre><code>def values(self) -&gt; tuple[Any, ...]:\n\"\"\"Emulates python dict 'values' method.\n    Returns:\n        tuple[Any, ...]: a tuple equivalent to dict.values(). A Hybrid\n            cannot actually create an ValuesView because that would\n            eliminate any duplicate keys, which are permitted by Hybrid.\n    \"\"\"\nreturn tuple(self.contents)\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Listing","title":"<code>Listing</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Bunch</code>, <code>MutableSequence</code></p> <p>Basic camina list replacement.</p> <p>A Listing differs from an ordinary python list in ways required by inheriting from Bunch: 'add', 'delete', and 'subset' methods, and allowing the '+' operator to join Listings with other list-like objects) and in 1 other way:     1) It includes a 'prepend' method for adding one or more items to the         beginning of the stored list.</p> <p>The 'add' method attempts to extend 'contents' with the item to be added. If this fails, it appends the item to 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>MutableSequence[Any]</code> <p>items to store in a list. Defaults to an empty list.</p> <code>field(default_factory=list)</code>"},{"location":"reference/camina/sequence/#camina.sequence.Listing.contents","title":"<code>contents: MutableSequence[Any] = dataclasses.field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Instance Methods</p>"},{"location":"reference/camina/sequence/#camina.sequence.Listing.add","title":"<code>add(item)</code>","text":"<p>Tries to extend 'contents' with 'item'. Otherwise, it appends.</p> <p>The method will extend all passed sequences, except str types, which it will append.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | Sequence[Any]</code> <p>item(s) to add to 'contents'.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def add(self, item: Any | Sequence[Any]) -&gt; None:\n\"\"\"Tries to extend 'contents' with 'item'. Otherwise, it appends.\n    The method will extend all passed sequences, except str types, which it\n    will append.\n    Args:\n        item (Any | Sequence[Any]): item(s) to add to 'contents'.\n    \"\"\"\nif miller.is_sequence(item = item):\nself.contents.extend(item)\nelse:\nself.contents.append(item)\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Listing.delete","title":"<code>delete(item)</code>","text":"<p>Deletes item at the index in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any</code> <p>index in 'contents' to delete.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def delete(self, item: int) -&gt; None:\n\"\"\"Deletes item at the index in 'contents'.\n    Args:\n        item (Any): index in 'contents' to delete.\n    \"\"\"\ndel self.contents[item]\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Listing.insert","title":"<code>insert(index, item)</code>","text":"<p>Inserts 'item' at 'index' in 'contents'.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>index to insert 'item' at.</p> required <code>item</code> <code>Any</code> <p>object to be inserted.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def insert(self, index: int, item: Any) -&gt; None:\n\"\"\"Inserts 'item' at 'index' in 'contents'.\n    Args:\n        index (int): index to insert 'item' at.\n        item (Any): object to be inserted.\n    \"\"\"\nself.contents.insert(index, item)\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Listing.prepend","title":"<code>prepend(item)</code>","text":"<p>Prepends 'item' to 'contents'.</p> <p>If 'item' is a non-str sequence, 'prepend' adds its contents to the stored list in the order they appear in 'item'.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Any | Sequence[Any]</code> <p>item(s) to prepend to 'contents'.</p> required Source code in <code>src/camina/sequence.py</code> <pre><code>def prepend(self, item: Any | Sequence[Any]) -&gt; None:\n\"\"\"Prepends 'item' to 'contents'.\n    If 'item' is a non-str sequence, 'prepend' adds its contents to the\n    stored list in the order they appear in 'item'.\n    Args:\n        item (Any | Sequence[Any]): item(s) to prepend to 'contents'.\n    \"\"\"\nif miller.is_sequence(item = item):\nfor thing in reversed(item):\nself.prepend(item = thing)\nelse:\nself.insert(0, item)\nreturn\n</code></pre>"},{"location":"reference/camina/sequence/#camina.sequence.Listing.subset","title":"<code>subset(include=None, exclude=None)</code>","text":"<p>Returns a new instance with a subset of 'contents'.</p> <p>This method applies 'include' before 'exclude' if both are passed. If 'include' is None, all existing items will be added to the new subset class instance before 'exclude' is applied.</p> <p>Parameters:</p> Name Type Description Default <code>include</code> <code>Optional[Any | Sequence[Any]]</code> <p>item(s) to include in the new instance. Defaults to None.</p> <code>None</code> <code>exclude</code> <code>Optional[Any | Sequence[Any]]</code> <p>item(s) to exclude in the new instance. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if 'include' and 'exclude' are both None.</p> <p>Returns:</p> Name Type Description <code>Listing</code> <code>Listing</code> <p>with only items from 'include' and no items in 'exclude'.</p> Source code in <code>src/camina/sequence.py</code> <pre><code>def subset(\nself,\ninclude: Any | Sequence[Any] | None = None,\nexclude: Any | Sequence[Any] | None = None) -&gt; Listing:\n\"\"\"Returns a new instance with a subset of 'contents'.\n    This method applies 'include' before 'exclude' if both are passed. If\n    'include' is None, all existing items will be added to the new subset\n    class instance before 'exclude' is applied.\n    Args:\n        include (Optional[Any | Sequence[Any]]): item(s) to include in\n            the new instance. Defaults to None.\n        exclude (Optional[Any | Sequence[Any]]): item(s) to exclude in\n            the new instance. Defaults to None.\n    Raises:\n        ValueError: if 'include' and 'exclude' are both None.\n    Returns:\n        Listing: with only items from 'include' and no items in 'exclude'.\n    \"\"\"\nif include is None and exclude is None:\nraise ValueError('include or exclude must not be None')\nelse:\nif include is None:\ncontents = copy.deepcopy(self.contents)\nelse:\ninclude = list(convert.iterify(include))\ncontents = [i for i in self.contents if i in include]\nif exclude is not None:\nexclude = list(convert.iterify(exclude))\ncontents = [i for i in contents if i not in exclude]\nnew_listing = copy.deepcopy(self)\nnew_listing.contents = contents\nreturn new_listing\n</code></pre>"}]}